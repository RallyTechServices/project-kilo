<!DOCTYPE html>
<html>
<head>
    <title>Portfolio Timesheet App</title>
    <!--  (c) 2016 CA Technologies.  All Rights Reserved. -->
    <!--  Build Date: Mon Sep 17 2018 16:30:41 GMT-0700 (PDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Mon Sep 17 2018 16:30:41 GMT-0700 (PDT)";
        var STORY    = "US8846";
        var BUILDER  = "rajan08";
        var CHECKSUM = 283166862533;
    </script>
    
    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
Ext.define('CA.technicalservices.ColumnPickerDialog',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tscolumnpickerdialog',

    width: 200,
    closable: true,

    config: {
        /**
         * @cfg {String}
         * Title to give to the dialog
         */
        title: 'Choose Columns',
        /**
         * @cfg {Boolean}
         * Allow multiple selection or not
         */
        multiple: true,
        /**
         *
         * @cfg [{Ext.Column.column}]  columns that
         * can be chosen.  hidden = false means chosen to
         * show.
         *
         */
        pickableColumns: [],

        selectionButtonText: 'Apply'

    },

    items: [{
        xtype: 'panel',
        border: false,
        items: [{
            xtype:'container',
            itemId:'grid_container',
            layout: 'fit',
            height: 325
        }]
    }],

    constructor: function(config) {
        this.mergeConfig(config);

        this.callParent([this.config]);
    },

    initComponent: function() {
        this.callParent(arguments);
        this.addEvents(
            /**
             * @event columnschosen
             * Fires when user clicks done after choosing columns
             * @param {CA.technicalservices.ColumnPickerDialog} this dialog
             * @param [{Ext.column.Column}] columns with hidden marked true/false as appropriate
             */
            'columnschosen'
        );

        this._buildButtons();
        //this._buildSearchBar();
        this._buildGrid();
    },

    _buildButtons: function() {
        this.down('panel').addDocked({
            xtype: 'toolbar',
            dock: 'bottom',
            padding: '0 0 10 0',
            layout: {
                type: 'hbox',
                pack: 'center'
            },
            ui: 'footer',
            items: [
                {
                    xtype: 'rallybutton',
                    text: this.selectionButtonText,
                    cls: 'primary small',
                    scope: this,
                    userAction: 'clicked done in dialog',
                    handler: function() {
                        var selectedRecords = this.getRecordsWithSelection();
                        this.fireEvent('columnschosen', this, selectedRecords);
                        this.close();
                    }
                },
                {
                    xtype: 'rallybutton',
                    text: 'Cancel',
                    cls: 'secondary small',
                    handler: this.close,
                    scope: this,
                    ui: 'link'
                }
            ]
        });
    },

    _buildGrid: function() {
        var mode = this.multiple ? 'MULTI' : 'SINGLE';
        this.selectionModel = Ext.create('Rally.ui.selection.CheckboxModel', {
            mode: mode,
            allowDeselect: true
        });

        var pickableColumns = this.pickableColumns;

        console.log('pickable columns', pickableColumns);

        var store = Ext.create('Rally.data.custom.Store',{
            data: this.pickableColumns
        });


        this.grid = Ext.create('Rally.ui.grid.Grid', {
            selModel: this.selectionModel,
            enableColumnHide: false,
            enableColumnMove: false,
            columnCfgs: this._getGridColumns(),
            showPagingToolbar: false,
            store: store,
            listeners: {
                viewready: function(grid) {
                    var selectionModel = grid.getSelectionModel();

                    Ext.Array.each(pickableColumns, function(col, idx){
                        if ( !col.hidden ) {
                            selectionModel.select(grid.store.data.items[idx],true);
                        }
                    });
                }
            }
        });

        this.down('#grid_container').add(this.grid);
    },

    _getGridColumns: function() {
        return [
            { dataIndex: 'text', flex: 1 }
        ];
    },

    getRecordsWithSelection: function() {
        var selected_items = this.grid.getSelectionModel().getSelection();
        var selected_items_by_dataindex = {};
        Ext.Array.each(selected_items, function(selected_item){
            selected_items_by_dataindex[selected_item.get('text')] = selected_item.getData();
        });

        Ext.Array.each(this.pickableColumns, function(pickableColumn){
            pickableColumn.hidden = Ext.isEmpty(selected_items_by_dataindex[pickableColumn.text]);
        });

        return this.pickableColumns;
    }
});
Ext.define('CA.technicalservices.ColumnPickerButton',{
    extend: 'Rally.ui.Button',
    requires: [
        'CA.technicalservices.ColumnPickerDialog'
    ],

    alias: 'widget.tscolumnpickerbutton',

    config: {
        pickableColumns: [],
        text: '<span class="icon-add-column"> </span>',
        cls: 'secondary'

    },

    constructor:function (config) {
        this.mergeConfig(config);

        this.callParent([this.config]);
    },

    initComponent: function() {
        this.callParent(arguments);
        this.addEvents(
            /**
             * @event columnschosen
             * Fires when user clicks done after choosing columns
             * @param {CA.technicalservices.ColumnPickerButton} this button
             * @param [{Ext.column.Column}] columns with hidden marked true/false as appropriate
             */
            'columnschosen'
        );
    },

    afterRender: function() {
        this.callParent(arguments);
        this.mon(this.el, this.clickEvent, this._showDialog, this);

    },

    _showDialog: function() {
        var me = this;
        Ext.create('CA.technicalservices.ColumnPickerDialog',{
            autoShow: true,
            pickableColumns: this.pickableColumns,
            listeners: {
                scope: this,
                columnschosen: function(dialog, columns) {
                    this.fireEvent('columnschosen', me, columns);
                }
            }
        });
    }
});
/* FileSaver.js
 *  A saveAs() FileSaver implementation.
 *  2014-05-27
 *
 *  By Eli Grey, http://eligrey.com
 *  License: X11/MIT
 *    See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs
  // IE 10+ (native saveAs)
  || (typeof navigator !== "undefined" &&
      navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator))
  // Everyone else
  || (function(view) {
    "use strict";
    // IE <10 is explicitly unsupported
    if (typeof navigator !== "undefined" &&
        /MSIE [1-9]\./.test(navigator.userAgent)) {
        return;
    }
    var
          doc = view.document
          // only get URL when necessary in case Blob.js hasn't overridden it yet
        , get_URL = function() {
            return view.URL || view.webkitURL || view;
        }
        , save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
        , can_use_save_link = !view.externalHost && "download" in save_link
        , click = function(node) {
            var event = doc.createEvent("MouseEvents");
            event.initMouseEvent(
                "click", true, false, view, 0, 0, 0, 0, 0
                , false, false, false, false, 0, null
            );
            node.dispatchEvent(event);
        }
        , webkit_req_fs = view.webkitRequestFileSystem
        , req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
        , throw_outside = function(ex) {
            (view.setImmediate || view.setTimeout)(function() {
                throw ex;
            }, 0);
        }
        , force_saveable_type = "application/octet-stream"
        , fs_min_size = 0
        , deletion_queue = []
        , process_deletion_queue = function() {
            var i = deletion_queue.length;
            while (i--) {
                var file = deletion_queue[i];
                if (typeof file === "string") { // file is an object URL
                    get_URL().revokeObjectURL(file);
                } else { // file is a File
                    file.remove();
                }
            }
            deletion_queue.length = 0; // clear queue
        }
        , dispatch = function(filesaver, event_types, event) {
            event_types = [].concat(event_types);
            var i = event_types.length;
            while (i--) {
                var listener = filesaver["on" + event_types[i]];
                if (typeof listener === "function") {
                    try {
                        listener.call(filesaver, event || filesaver);
                    } catch (ex) {
                        throw_outside(ex);
                    }
                }
            }
        }
        , FileSaver = function(blob, name) {
            // First try a.download, then web filesystem, then object URLs
            var
                  filesaver = this
                , type = blob.type
                , blob_changed = false
                , object_url
                , target_view
                , get_object_url = function() {
                    var object_url = get_URL().createObjectURL(blob);
                    deletion_queue.push(object_url);
                    return object_url;
                }
                , dispatch_all = function() {
                    dispatch(filesaver, "writestart progress write writeend".split(" "));
                }
                // on any filesys errors revert to saving with object URLs
                , fs_error = function() {
                    // don't create more object URLs than needed
                    if (blob_changed || !object_url) {
                        object_url = get_object_url(blob);
                    }
                    if (target_view) {
                        target_view.location.href = object_url;
                    } else {
                        window.open(object_url, "_blank");
                    }
                    filesaver.readyState = filesaver.DONE;
                    dispatch_all();
                }
                , abortable = function(func) {
                    return function() {
                        if (filesaver.readyState !== filesaver.DONE) {
                            return func.apply(this, arguments);
                        }
                    };
                }
                , create_if_not_found = {create: true, exclusive: false}
                , slice
            ;
            filesaver.readyState = filesaver.INIT;
            if (!name) {
                name = "download";
            }
            if (can_use_save_link) {
                object_url = get_object_url(blob);
                save_link.href = object_url;
                save_link.download = name;
                click(save_link);
                filesaver.readyState = filesaver.DONE;
                dispatch_all();
                return;
            }
            // Object and web filesystem URLs have a problem saving in Google Chrome when
            // viewed in a tab, so I force save with application/octet-stream
            // http://code.google.com/p/chromium/issues/detail?id=91158
            if (view.chrome && type && type !== force_saveable_type) {
                slice = blob.slice || blob.webkitSlice;
                blob = slice.call(blob, 0, blob.size, force_saveable_type);
                blob_changed = true;
            }
            // Since I can't be sure that the guessed media type will trigger a download
            // in WebKit, I append .download to the filename.
            // https://bugs.webkit.org/show_bug.cgi?id=65440
            if (webkit_req_fs && name !== "download") {
                name += ".download";
            }
            if (type === force_saveable_type || webkit_req_fs) {
                target_view = view;
            }
            if (!req_fs) {
                fs_error();
                return;
            }
            fs_min_size += blob.size;
            req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
                fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
                    var save = function() {
                        dir.getFile(name, create_if_not_found, abortable(function(file) {
                            file.createWriter(abortable(function(writer) {
                                writer.onwriteend = function(event) {
                                    target_view.location.href = file.toURL();
                                    deletion_queue.push(file);
                                    filesaver.readyState = filesaver.DONE;
                                    dispatch(filesaver, "writeend", event);
                                };
                                writer.onerror = function() {
                                    var error = writer.error;
                                    if (error.code !== error.ABORT_ERR) {
                                        fs_error();
                                    }
                                };
                                "writestart progress write abort".split(" ").forEach(function(event) {
                                    writer["on" + event] = filesaver["on" + event];
                                });
                                writer.write(blob);
                                filesaver.abort = function() {
                                    writer.abort();
                                    filesaver.readyState = filesaver.DONE;
                                };
                                filesaver.readyState = filesaver.WRITING;
                            }), fs_error);
                        }), fs_error);
                    };
                    dir.getFile(name, {create: false}, abortable(function(file) {
                        // delete file if it already exists
                        file.remove();
                        save();
                    }), abortable(function(ex) {
                        if (ex.code === ex.NOT_FOUND_ERR) {
                            save();
                        } else {
                            fs_error();
                        }
                    }));
                }), fs_error);
            }), fs_error);
        }
        , FS_proto = FileSaver.prototype
        , saveAs = function(blob, name) {
            return new FileSaver(blob, name);
        }
    ;
    FS_proto.abort = function() {
        var filesaver = this;
        filesaver.readyState = filesaver.DONE;
        dispatch(filesaver, "abort");
    };
    FS_proto.readyState = FS_proto.INIT = 0;
    FS_proto.WRITING = 1;
    FS_proto.DONE = 2;

    FS_proto.error =
    FS_proto.onwritestart =
    FS_proto.onprogress =
    FS_proto.onwrite =
    FS_proto.onabort =
    FS_proto.onerror =
    FS_proto.onwriteend =
        null;

    view.addEventListener("unload", process_deletion_queue, false);
    saveAs.unload = function() {
        process_deletion_queue();
        view.removeEventListener("unload", process_deletion_queue, false);
    };
    return saveAs;
}(
       typeof self !== "undefined" && self
    || typeof window !== "undefined" && window
    || this.content
));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== "undefined" && module !== null) {
  module.exports = saveAs;
} else if ((typeof define !== "undefined" && define !== null) && (define.amd != null)) {
  define([], function() {
    return saveAs;
  });
}
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",
    
    defaults: { padding: 5, margin: 5 },

    closable: true,
     
    draggable: true,

    autoShow: true,
   
    width: 350,
    
    informationalConfig: null,
    
    items: [{xtype:'container', itemId:'information' }],
    
    initComponent: function() {
        var id = Ext.id(this);
        this.title =  "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },
    
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/var BUILDER  = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
       
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
   
        return chk;
    },
    
    _checkChecksum: function(container) {
        var deferred = Ext.create('Deft.Deferred');
        var me = this;
        
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    var stored_checksum = me._generateChecksum(text);
                    if ( CHECKSUM !== stored_checksum ) {
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });
        
        return deferred.promise;
    },
    
    _addToContainer: function(container){
        var config = Ext.apply({
            xtype:'container',
            height: 200,
            overflowY: true
        }, this.informationalConfig);
        
        container.add(config);
    },
    
    afterRender: function() {
        var app = Rally.getApp();
        
        if ( !Ext.isEmpty( this.informationalConfig ) ) {
            var container = this.down('#information');
            this._addToContainer(container);
            
        }
        
        if (! app.isExternal() ) {
            this._checkChecksum(app).then({
                scope: this,
                success: function(result){
                    if ( !result ) {
                        this.addDocked({
                            xtype:'container',
                            cls: 'build-info',
                            dock: 'bottom',
                            padding: 2,
                            html:'<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                },
                failure: function(msg){
                    console.log("oops:",msg);
                }
            });
        } else {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html:'... Running externally'
            });
        }
        this.callParent(arguments);
    },
    
    beforeRender: function() {
        var me = this;
        this.callParent(arguments);

        if (this.informationHtml) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: this.informationHtml,
                doc: 'top'
            });
        }
        
        this.addDocked({
            xtype:'container',
            cls: 'build-info',
            padding: 2,
            dock:'bottom',
            html:"This app was created by the CA AC Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            var build_html = Ext.String.format("Built on: {0} <br/>Built by: {1}",
                APP_BUILD_DATE,
                BUILDER);
                
            if ( STORY ) {
                build_html = build_html + "<br/>Source story: " + STORY;
            }
                
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html: build_html
            });
        }
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.override(Ext.grid.feature.Grouping, {

    setupRowData: function(record, idx, rowValues) {
        var me = this,
            data = me.refreshData,
            groupInfo = me.groupInfo,
            header = data.header,
            groupField = data.groupField,
            dataSource = me.view.dataSource,
            grouper, groupName, prev, next;

        rowValues.isCollapsedGroup = false;
        rowValues.summaryRecord = null;

        if (data.doGrouping) {
            grouper = me.view.store.groupers.first();

            // This is a placeholder record which represents a whole collapsed group
            // It is a special case.
            if (record.children) {
                groupName = grouper.getGroupString(record.children[0]);

                rowValues.isFirstRow = rowValues.isLastRow = true;
                rowValues.itemClasses.push(me.hdCollapsedCls);
                rowValues.isCollapsedGroup = rowValues.needsWrap = true;
                rowValues.groupInfo = groupInfo;
                groupInfo.groupField = groupField;
                groupInfo.name = groupName;
                groupInfo.groupValue = record.children[0].get(groupField);
                groupInfo.columnName = header ? header.text : groupField;
                rowValues.collapsibleCls = me.collapsible ? me.collapsibleCls : me.hdNotCollapsibleCls;
                rowValues.groupId = me.createGroupId(groupName);
                groupInfo.rows = groupInfo.children = record.children;
                if (me.showSummaryRow) {
                    rowValues.summaryRecord = data.summaryData[groupName];
                }
                return;
            }

            groupName = grouper.getGroupString(record);

            // If caused by an update event on the first or last records of a group fired by a GroupStore, the record's group will be attached.
            if (record.group) {
                rowValues.isFirstRow = record === record.group.children[0];
                rowValues.isLastRow  = record === record.group.children[record.group.children.length - 1];
            }

            else {
                // See if the current record is the last in the group
                rowValues.isFirstRow = idx === 0;
                if (!rowValues.isFirstRow) {
                    prev = dataSource.getAt(idx - 1);
                    // If the previous row is of a different group, then we're at the first for a new group
                    if (prev) {
                        // Must use Model's comparison because Date objects are never equal
                        rowValues.isFirstRow = !prev.isEqual(grouper.getGroupString(prev), groupName);
                    }
                }

                // See if the current record is the last in the group
                rowValues.isLastRow = idx == dataSource.getTotalCount() - 1;
                if (!rowValues.isLastRow) {
                    next = dataSource.getAt(idx + 1);
                    if (next) {
                        // Must use Model's comparison because Date objects are never equal
                        rowValues.isLastRow = !next.isEqual(grouper.getGroupString(next), groupName);
                    }
                }
            }

            if (rowValues.isFirstRow) {
                groupInfo.groupField = groupField;
                groupInfo.name = groupName;
                groupInfo.groupValue = record.get(groupField);
                groupInfo.columnName = header ? header.text : groupField;
                rowValues.collapsibleCls = me.collapsible ? me.collapsibleCls : me.hdNotCollapsibleCls;
                rowValues.groupId = me.createGroupId(groupName);

                if (!me.isExpanded(groupName)) {
                    rowValues.itemClasses.push(me.hdCollapsedCls);
                    rowValues.isCollapsedGroup = true;
                }

                // We only get passed a GroupStore if the store is not buffered
                if (dataSource.buffered) {
                    groupInfo.rows = groupInfo.children = [];
                } else {
                    groupInfo.rows = groupInfo.children = me.getRecordGroup(record).children;
                }
                rowValues.groupInfo = groupInfo;
            }

            if (rowValues.isLastRow) {
                // Add the group's summary record to the last record in the group
                if (me.showSummaryRow) {
                    rowValues.summaryRecord = data.summaryData[groupName];
                }
            }
            rowValues.needsWrap = (rowValues.isFirstRow || rowValues.summaryRecord);
        }
    },

    setup: function(rows, rowValues) {
        var me = this,
            data = me.refreshData,
            isGrouping = !me.disabled && me.view.store.isGrouped();
            
        me.skippedRows = 0;
        if (rowValues.view.bufferedRenderer) {
            rowValues.view.bufferedRenderer.variableRowHeight = true;
        }
        data.groupField = me.getGroupField();
        data.header = me.getGroupedHeader(data.groupField);
        data.doGrouping = isGrouping;
        rowValues.groupHeaderTpl = Ext.XTemplate.getTpl(me, 'groupHeaderTpl');

        if (isGrouping && me.showSummaryRow) {
            data.summaryData = me.generateSummaryData();
        }
    },    

    generateSummaryData: function(){
        var me = this,
            store = me.view.store,
            groups = store.groups.items,
            reader = store.proxy.reader,
            len = groups.length,
            groupField = me.getGroupField(),
            data = {},
            lockingPartner = me.lockingPartner,
            i, group, record,
            root, summaryRows, hasRemote,
            convertedSummaryRow, remoteData;

        /**
         * @cfg {String} [remoteRoot=undefined]
         * The name of the property which contains the Array of summary objects.
         * It allows to use server-side calculated summaries.
         */
        if (me.remoteRoot && reader.rawData) {
            hasRemote = true;
            remoteData = {};
            // reset reader root and rebuild extractors to extract summaries data
            root = reader.root;
            reader.root = me.remoteRoot;
            reader.buildExtractors(true);
            summaryRows = reader.getRoot(reader.rawData)||[];
            len = summaryRows.length;

            // Ensure the Reader has a data conversion function to convert a raw data row into a Record data hash
            if (!reader.convertRecordData) {
                reader.buildExtractors();
            }

            for (i = 0; i < len; ++i) {
                convertedSummaryRow = {};

                // Convert a raw data row into a Record's hash object using the Reader
                reader.convertRecordData(convertedSummaryRow, summaryRows[i]);
                remoteData[convertedSummaryRow[groupField]] = convertedSummaryRow;
            }

            // restore initial reader configuration
            reader.root = root;
            reader.buildExtractors(true);
        }

        for (i = 0; i < len; ++i) {
            group = groups[i];
            // Something has changed or it doesn't exist, populate it
            if (hasRemote || group.isDirty() || !group.hasAggregate()) {
                if (hasRemote) {
                    record = me.populateRemoteRecord(group, remoteData);
                } else {
                    record = me.populateRecord(group);
                }
                // Clear the dirty state of the group if this is the only Summary, or this is the right hand (normal grid's) summary
                if (!lockingPartner || (me.view.ownerCt === me.view.ownerCt.ownerLockable.normalGrid)) {
                    group.commit();
                }
            } else {
                record = group.getAggregateRecord();
            }
            data[group.key] = record;
        }

        return data;
    }

});

Ext.override(Ext.grid.GridPanel, {
    applyState: function(state) {
        var me = this;
        me.callParent(arguments);
        if(state && state.storeState && state.storeState.groupers){
            this.store.group(state.storeState.groupers);
        }
    }
});

Ext.override(Ext.util.Filter, {
    operatorFns: {
        "<": function(candidate) {
            return Ext.coerce(this.getRoot(candidate)[this.property], this.value) < this.value;
        },
        "<=": function(candidate) {
            return Ext.coerce(this.getRoot(candidate)[this.property], this.value) <= this.value;
        },
        "=": function(candidate) {
            return Ext.coerce(this.getRoot(candidate)[this.property] && this.getRoot(candidate)[this.property].toLowerCase(), this.value.toLowerCase()) == this.value.toLowerCase();
        },
        ">=": function(candidate) {
            return Ext.coerce(this.getRoot(candidate)[this.property], this.value) >= this.value;
        },
        ">": function(candidate) {
            return Ext.coerce(this.getRoot(candidate)[this.property], this.value) > this.value;
        },
        "!=": function(candidate) {
            return Ext.coerce(this.getRoot(candidate)[this.property] && this.getRoot(candidate)[this.property].toLowerCase(), this.value.toLowerCase()) != this.value.toLowerCase();
        },
        "contains": function(candidate) {
            return Ext.coerce(this.getRoot(candidate)[this.property] && this.getRoot(candidate)[this.property].toLowerCase(), this.value.toLowerCase()).indexOf(this.value.toLowerCase()) !== -1;
        },
        "!contains": function(candidate) {
            return Ext.coerce(this.getRoot(candidate)[this.property] && this.getRoot(candidate)[this.property].toLowerCase(), this.value.toLowerCase()).indexOf(this.value.toLowerCase()) == -1;
        }
    }

});
Ext.define('Rally.technicalservices.FileUtilities', {
    singleton: true,
    logger: new Rally.technicalservices.Logger(),
    saveCSVToFile:function(csv,file_name,type_object){
            if (type_object == undefined){
                type_object = {type:'text/csv;charset=utf-8'};
            }
            var blob = new Blob([csv],type_object);
            saveAs(blob,file_name);
    },

    saveXMLToFile:function(xml,file_name,type_object){
            if (type_object == undefined){
                type_object = {type:'text/xml;charset=utf-8'};
            }
            var blob = new Blob([xml],type_object);
            saveAs(blob,file_name);
    },

    saveTextAsFile: function(textToWrite, fileName) {
        var textFileAsBlob = new Blob([textToWrite], {type:'text/plain'});
        var fileNameToSaveAs = fileName;

        var downloadLink = document.createElement("a");
        downloadLink.download = fileNameToSaveAs;
        downloadLink.innerHTML = "Download File";
        if (window.webkitURL != null)
        {
            // Chrome allows the link to be clicked
            // without actually adding it to the DOM.
            downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob);
        }
        else
        {
            // Firefox requires the link to be added to the DOM
            // before it can be clicked.
            downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
            downloadLink.onclick = destroyClickedElement;
            downloadLink.style.display = "none";
            document.body.appendChild(downloadLink);
        }
        downloadLink.click();
    },
    destroyClickedElement: function(event)
    {
        document.body.removeChild(event.target);
    },
    convertDataArrayToCSVText: function(data_array, requestedFieldHash){
       
        var text = '';
        Ext.each(Object.keys(requestedFieldHash), function(key){
            text += requestedFieldHash[key] + ',';
        });
        text = text.replace(/,$/,'\n');
        
        Ext.each(data_array, function(d){
            Ext.each(Object.keys(requestedFieldHash), function(key){
                if (d[key]){
                    if (typeof d[key] === 'object'){
                        if (d[key].FormattedID) {
                            text += Ext.String.format("\"{0}\",",d[key].FormattedID ); 
                        } else if (d[key].Name) {
                            text += Ext.String.format("\"{0}\",",d[key].Name );                    
                        } else if (!isNaN(Date.parse(d[key]))){
                            text += Ext.String.format("\"{0}\",",Rally.util.DateTime.formatWithDefaultDateTime(d[key]));
                        }else {
                            text += Ext.String.format("\"{0}\",",d[key].toString());
                        }
                    } else {
                        text += Ext.String.format("\"{0}\",",d[key] );                    
                    }
                } else {
                    text += ',';
                }
            },this);
            text = text.replace(/,$/,'\n');
        },this);
        return text;
    },
    _getCSVFromWsapiBackedGrid: function(grid) {
        var deferred = Ext.create('Deft.Deferred');
        var store = Ext.create('Rally.data.wsapi.Store',{
            fetch: grid.getStore().config.fetch,
            filters: grid.getStore().config.filters,
            model: grid.getStore().config.model,
            limit:Infinity,
            pageSize: Infinity

        });
        
        var columns = grid.columns;
        var headers = this._getHeadersFromGrid(grid);
        var column_names = this._getColumnNamesFromGrid(grid);
        
        var record_count = grid.getStore().getTotalCount(),
            page_size = grid.getStore().pageSize,
            pages = Math.ceil(record_count/page_size),
            promises = [];

        for (var page = 1; page <= pages; page ++ ) {
            promises.push(this.loadStorePage(grid, store, columns, page, pages));
        }
        Deft.Promise.all(promises).then({
            success: function(csvs){
                var csv = [];
                csv.push('"' + headers.join('","') + '"');
                _.each(csvs, function(c){
                    _.each(c, function(line){
                        csv.push(line);
                    });
                });
                csv = csv.join('\r\n');
                deferred.resolve(csv);
                Rally.getApp().setLoading(false);
            }
        });
        return deferred.promise;
    },

    // custom grid assumes there store is fully loaded
    _getCSVFromCustomBackedGridWithPaging: function(grid) {
        var deferred = Ext.create('Deft.Deferred');


        var store = Ext.create('Rally.data.custom.Store',{
            model: grid.getStore().config.model,
            filters: grid.getStore().config.filters,
            limit:Infinity,
            pageSize: Infinity
        });

        var columns = grid.columns;
        var headers = this._getHeadersFromGrid(grid);
        var column_names = this._getColumnNamesFromGrid(grid);
        
        var record_count = grid.getStore().getTotalCount(),
            page_size = grid.getStore().pageSize,
            pages = Math.ceil(record_count/page_size),
            promises = [];

        // for (var page = 1; page <= pages; page ++ ) {
        //     promises.push(this.loadStorePage(grid, store, columns, page, pages));
        // }

        promises.push(this.loadStorePage(grid, store, columns, page, pages));

        Deft.Promise.all(promises).then({
            success: function(csvs){
                var csv = [];
                csv.push('"' + headers.join('","') + '"');
                _.each(csvs, function(c){
                    _.each(c, function(line){
                        csv.push(line);
                    });
                });
                csv = csv.join('\r\n');
                deferred.resolve(csv);
                Rally.getApp().setLoading(false);
            }
        });
        return deferred.promise;

        // var headers = this._getHeadersFromGrid(grid);
        
        // var columns = grid.columns;
        // var column_names = this._getColumnNamesFromGrid(grid);

       
        // var csv = [];
        // csv.push('"' + headers.join('","') + '"');

        // var number_of_records = store.getTotalCount();
        
        // this.logger.log("Number of records to export:", number_of_records);
        
        // for (var i = 0; i < number_of_records; i++) {
        //     var record = store.getAt(i);
        //     if ( ! record ) {
        //         this.logger.log("Number or lines in CSV:", csv.length);
        //         return csv.join('\r\n');            }
        //     csv.push( this._getCSVFromRecord(record, grid, store) );
        // }
        
        // this.logger.log("Number or lines in CSV:", csv.length);
        // return csv.join('\r\n');
    },

    
    // custom grid assumes there store is fully loaded
    _getCSVFromCustomBackedGrid: function(grid) {
    var deferred = Ext.create('Deft.Deferred');
            var me = this;
            
            Rally.getApp().setLoading("Assembling data for export...");
            
            var headers = this._getHeadersFromGrid(grid);
            var store = Ext.clone( grid.getStore() );
            var columns = grid.columns;
            var column_names = this._getColumnNamesFromGrid(grid);
            
            var record_count = grid.getStore().getTotalCount();
            var original_page_size = grid.getStore().pageSize;
            
            var page_size = 20000;
            var number_of_pages = Math.ceil(record_count/page_size);
            store.pageSize = page_size;
            
            var pages = [],
                promises = [];

            for (var page = 1; page <= number_of_pages; page ++ ) {
                pages.push(page);
            }
            
            Ext.Array.each(pages, function(page) {
                promises.push(function() { 
                    return me._loadStorePage(grid, store, columns, page, pages.length )
                });
            });
            
            Deft.Chain.sequence(promises).then({
                success: function(csvs){

                    // set page back to last view
                    store.pageSize = original_page_size;
                    store.loadPage(1);
                    
                    var csv = [];
                    csv.push('"' + headers.join('","') + '"');
                    _.each(csvs, function(c){
                        _.each(c, function(line){
                            csv.push(line);
                        });
                    });
                    csv = csv.join('\r\n');
                    deferred.resolve(csv);
                    Rally.getApp().setLoading(false);
                }
            });
            
            return deferred.promise;
    },
    


    _loadStorePage: function(grid, store, columns, page, total_pages){
        var deferred = Ext.create('Deft.Deferred');

        store.loadPage(page, {
            callback: function (records) {
                var csv = [];
                for (var i = 0; i < records.length; i++) {
                    // if(i==0){
                    //     Rally.getApp().setLoading("Loading page "+page+ " of "+total_pages);
                    // }
                    var record = records[i];
                    csv.push( this._getCSVFromRecord(record, grid, store) );
                }
                deferred.resolve(csv);
            },
            scope: this
        });
        this.logger.log("_loadStorePage", page, " of ", total_pages);
        return deferred.promise;
    },


    _getHeadersFromGrid: function(grid) {
        var headers = [];        
        var columns = grid.columns;

        Ext.Array.each(columns,function(column){
            if ( column.dataIndex || column.renderer ) {
                if ( column.csvText ) {
                    headers.push(column.csvText.replace('&nbsp;',' '));
                } else if ( column.text )  {
                    headers.push(column.text.replace('&nbsp;',' '));
                }
            }
        });
        
        return headers;
    },
    
    _getColumnNamesFromGrid: function(grid) {
        var names = [];
        var columns = grid.columns;

        Ext.Array.each(columns,function(column){
            if ( column.dataIndex || column.renderer ) {
                names.push(column.dataIndex);
            }
        });
        
        return names;
    },
    /*
     * will render using your grid renderer.  If you want it to ignore the grid renderer, 
     * have the column set _csvIgnoreRender: true
     */
    getCSVFromGrid:function(app, grid){
        this.logger.log("Exporting grid with store type:", Ext.getClassName(grid.getStore()));
        
        if ( Ext.getClassName(grid.getStore()) != "Rally.data.custom.Store" ) {
            return this._getCSVFromWsapiBackedGrid(grid);
        }
        
        return this._getCSVFromCustomBackedGrid(grid);
    },

    loadStorePage: function(grid, store, columns, page, total_pages){
        console.log('Inside loadStorePage');
        var deferred = Ext.create('Deft.Deferred');
        this.logger.log('loadStorePage',page, total_pages);

        store.loadPage(page, {
            callback: function (records, operation, success) {
                //console.log(' page records length',records.length,'success',success);
                var csv = [];
                Rally.getApp().setLoading(Ext.String.format('Page {0} of {1} loaded',page, total_pages));
                for (var i = 0; i < records.length; i++) {
                    var record = records[i];
                    csv.push( this._getCSVFromRecord(record, grid, store) );
                }
                deferred.resolve(csv);
            },
            scope: this
        });
        return deferred;
    },
    
    _getCSVFromRecord: function(record, grid, store) {
        var mock_meta_data = {
            align: "right",
            classes: [],
            cellIndex: 9,
            column: null,
            columnIndex: 9,
            innerCls: undefined,
            recordIndex: 5,
            rowIndex: 5,
            style: "",
            tdAttr: "",
            tdCls: "x-grid-cell x-grid-td x-grid-cell-headerId-gridcolumn-1029 x-grid-cell-last x-unselectable",
            unselectableAttr: "unselectable='on'"
        };
        
        var node_values = [];
        var columns = grid.columns;
        //console.log('inside _getCSVFromRecord');
        Ext.Array.each(columns, function (column) {
            if (column.xtype != 'rallyrowactioncolumn') {
                if (column.dataIndex) {
                    var column_name = column.dataIndex;
                    
                    var display_value = record.get(column_name);

                    if (!column._csvIgnoreRender && column.renderer) {
                        if (column.exportRenderer) {
                            display_value = column.exportRenderer(display_value, mock_meta_data, record, 0, 0, store, grid.getView());
                        } else {
                            display_value = column.renderer(display_value, mock_meta_data, record, 0, 0, store, grid.getView());
                        }
                    }
                    node_values.push(display_value);
                } else {
                    var display_value = null;
                    if (!column._csvIgnoreRender && column.renderer) {
                        if (column.exportRenderer) {
                            display_value = column.exportRenderer(display_value, mock_meta_data, record, record, 0, 0, store, grid.getView());
                        } else {
                            display_value = column.renderer(display_value, mock_meta_data, record, record, 0, 0, store, grid.getView());
                        }
                        node_values.push(display_value);
                    }
                }

            }
        }, this);
        //console.log('Node values',node_values);
        return '"' + node_values.join('","') + '"';
    }

});
Ext.define("GridExporter", {
    //dateFormat : 'Y-m-d g:i',
    dateFormat: 'Y-m-d',

    inheritableStatics: {
        XmlFileHeader: '<?xml version="1.0"?>',
        XmlFileExtension: '.xml'
    },

    // _downloadFiles: function(files) {

    //     Ext.Array.each(files)

    //     if (files.length) {
    //         var data = files.pop();
    //         var format = files.pop();
    //         var file = files.pop();

    //         var href = "<a href='" + format + "," + encodeURIComponent(data) + "' download='" + file + "'></a>";

    //         var ml = Ext.DomHelper.insertAfter(window.document.getElementById('tsGrid'), href);
    //         ml.click();
    //         //            ml.remove(); //Leaves them behind without this, but there is a timing issue: from click to remove.
    //         this._downloadFiles(files);
    //     }
    // },

    exportCSV: function(grid) {
        var data = this._getCSV(grid, false);
        // fix: ' character was causing termination of csv file
        data = data.replace(/\'/g, "");
        // this._downloadFiles(
        //     [
        //         'export.csv', 'data:text/csv;charset=utf8', data
        //     ]
        // );
        Rally.technicalservices.FileUtilities.saveCSVToFile(data,'export.csv');
    },

    _XMLIndent: function(index, tag, leaf, data) {
        if (leaf === true)
            data = _.escape(data);

        var text = '\n';
        for (var i = 0; i < index; i++) text += '\t';
        text += '<' + tag + '>';
        text += data;
        if (!leaf) {
            text += '\n';
            for (i = 0; i < index; i++) text += '\t';
        }
        text += '</' + tag + '>';
        return text;

    },

    _addSAPTrailerFile: function(data) {

        var file = 'E1BPCATS8';
        var format = 'data:text/text;charset=utf8';
        var text = this.self.XmlFileHeader;

        text += "\n<" + file + ">";
        _.each(data, function(record) {
            if (record.get('c_SAPNetwork') && record.get('c_SAPOperation') && record.get('c_KMDEmployeeID')) {
                text += this._XMLIndent(1, 'Datarow', false,
                    this._XMLIndent(2, 'GUID', true, record.get('ObjectID')) +
                    this._XMLIndent(2, 'ROW', true, '1') +
                    this._XMLIndent(2, 'FORMAT_COL', true, '*') +
                    // this._XMLIndent(2, 'TEXT_LINE', true, '')
                    this._XMLIndent(2, 'TEXT_LINE', true, record.get('TaskDisplayString') || record.get('WorkProductDisplayString') || '')
                );
            }
        }, this);

        text += "</" + file + ">\n";
        file += this.self.XmlFileExtension;
        return Rally.technicalservices.FileUtilities.saveXMLToFile(text,file); //[file, format, text];
    },

    _addSAPHeaderFile: function(data) {

        var file = 'E1CATS_INSERT';
        var format = 'data:text/text;charset=utf8';
        var text = this.self.XmlFileHeader;

        text += "\n<" + file + ">";
        _.each(data, function(record) {
            if (record.get('c_SAPNetwork') && record.get('c_SAPOperation') && record.get('c_KMDEmployeeID')) {
                text += this._XMLIndent(1, 'Datarow', false,
                    this._XMLIndent(2, 'GUID', true, record.get('ObjectID')) +
                    this._XMLIndent(2, 'PROFILE', true, record.get('c_KMDEmployeeID') || '') +
                    this._XMLIndent(2, 'TEXT_FORMAT_IMP', true, 'ITF')
                );
            }
        }, this);

        text += "</" + file + ">\n";
        file += this.self.XmlFileExtension;
        return Rally.technicalservices.FileUtilities.saveXMLToFile(text,file); //[file, format, text];
    },

    _addSAPDataFile: function(data,xmlConfig) {
        console.log('xmlConfig>>>>>',xmlConfig);
        var file = 'E1BPCATS1';
        var format = 'data:text/text;charset=utf8';
        var text = this.self.XmlFileHeader;

        text += "\n<" + file + ">";
        _.each(data, function(record) {
            if (record.get('c_SAPNetwork') && record.get('c_SAPOperation') && record.get('c_KMDEmployeeID')) {
                text += this._XMLIndent(1, 'Datarow', false,
                    this._XMLIndent(2, 'GUID', true, record.get('ObjectID') || '') +
                    this._XMLIndent(2, 'WORKDATE', true, record.get('Date')) /*Ext.Date.format(new Date(record.get('Date')), 'Ymd')) */ +
                    this._XMLIndent(2, 'EMPLOYEENUMBER', true, record.get('c_KMDEmployeeID') || '') +
                    this._XMLIndent(2, 'ACTTYPE', true, '1') +
                    this._XMLIndent(2, 'NETWORK', true, record.get('c_SAPNetwork') || '') +
                    this._XMLIndent(2, 'ACTIVITY', true, record.get('c_SAPOperation') || '') +
                    (record.get('c_SAPSubOperation') ? this._XMLIndent(2, 'SUB_ACTIVITY', true, record.get('c_SAPSubOperation')) : '') +
                    this._XMLIndent(2, 'CATSHOURS', true, record.get('Hours')) +
                    this._XMLIndent(2, 'UNIT', true, 'H') +
                    this._XMLIndent(2, 'SHORTTEXT', true, record.get('TaskDisplayString') || record.get('WorkProductDisplayString') || '') +
                    (xmlConfig.extApplication ? this._XMLIndent(2, 'EXTAPPLICATION', true, xmlConfig.extApplicationValue ) : '') + 
                    this._XMLIndent(2, 'LONGTEXT', true, 'X')
                );
            }
        }, this);
        text += "</" + file + ">\n";
        file += this.self.XmlFileExtension;
        return Rally.technicalservices.FileUtilities.saveXMLToFile(text,file); //[file, format, text];

    },

    _addSAPErrorsFile: function(grid) {
        var file = 'SAPErrors.csv';
        var format = 'data:text/csv;charset=utf8';

        var text = this._getCSV(grid, true);
        if (text) return Rally.technicalservices.FileUtilities.saveCSVToFile(text,file);
        else return null;
    },

    exportSAPXML: function(grid,xmlConfig) {

        var filesToSave = [];

        if (grid && grid.store && grid.store.data) {
            var data = grid.store.data.items;
            var errors = this._addSAPErrorsFile(grid);

            //            if (errors) {
            //this._downloadFiles(errors);
            //            }
            //            else {
            //this._downloadFiles(filesToSave.concat(
                this._addSAPHeaderFile(data),
                this._addSAPDataFile(data,xmlConfig),
                this._addSAPTrailerFile(data)
            //));
            //            }
        }

    },

    _escapeForCSV: function(string) {
        string = "" + string;
        if (string.match(/,/)) {
            if (!string.match(/"/)) {
                string = '"' + string + '"';
            } else {
                string = string.replace(/,/g, ''); // comma's and quotes-- sorry, just lose the commas
            }
        }
        return string;
    },

    _getFieldText: function(fieldData, record, col, index) {
        var text;

        if (fieldData === null || fieldData === undefined) {
            text = '';

        } else if (fieldData._refObjectName && !fieldData.getMonth) {
            text = fieldData._refObjectName;

        } else if (fieldData instanceof Date) {
            text = Ext.Date.format(fieldData, this.dateFormat);

        }
        /*else if (!fieldData.match) { // not a string or object we recognize...bank it out
                   text = '';
               } */
        else {
            text = fieldData;
        }

        return text;
    },

    _getFieldTextAndEscape: function(fieldData, record, col, index) {
        var string = this._getFieldText(fieldData, record, col, index);

        return this._escapeForCSV(string);
    },

    // have to add the colIdx to the count of locked columns
    fixedColumnCount: function(columns) {
        var cols = _.filter(columns, function(c) {
            return c !== undefined && c !== null && c.locked === true;
        });
        return cols.length;
    },

    _getCSV: function(grid, onlyErrors) {
        var cols = grid.columns;
        var store = grid.store;
        var hdrData = '';
        var rowData = '';
        var valid = true;

        var that = this;
        Ext.Array.each(cols, function(col, index) {
            // Ext.Array.each(sortedCols, function(col, index) { 
            // console.log(col);
            if (col.hidden !== true) {
                // fix the issue with the "SYLK" warning in excel by prepending "Item" to the ID column
                var colLabel = col.dataIndex;
                //                var colLabel = (index === 0 ? "Item " : "") + col.dataIndex;
                colLabel = colLabel.replace(/<br\/?>/, '');
                hdrData += that._getFieldTextAndEscape(colLabel) + ',';
            }
        });
        hdrData += "\n";

        _.each(store.data.items, function(record, i) {
            valid = record.get('c_SAPNetwork') && record.get('c_SAPOperation') && record.get('c_KMDEmployeeID');
            if ((!onlyErrors) || (!valid)) {
                Ext.Array.each(cols, function(col, index) {

                    if (col.hidden !== true) {
                        var fieldName = col.dataIndex;
                        var text = record.get(fieldName);
                        rowData += that._getFieldTextAndEscape(text, record, col, index) + ',';
                    }
                });
                rowData += "\n";
            }
        });

        return hdrData + rowData;
    }
});
/*
 Copyright (c) 2013 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

(function(obj) {
    "use strict";

    var ERR_BAD_FORMAT = "File format is not recognized.";
    var ERR_CRC = "CRC failed.";
    var ERR_ENCRYPTED = "File contains encrypted entry.";
    var ERR_ZIP64 = "File is using Zip64 (4gb+ file size).";
    var ERR_READ = "Error while reading zip file.";
    var ERR_WRITE = "Error while writing zip file.";
    var ERR_WRITE_DATA = "Error while writing file data.";
    var ERR_READ_DATA = "Error while reading file data.";
    var ERR_DUPLICATED_NAME = "File already exists.";
    var CHUNK_SIZE = 512 * 1024;

    var TEXT_PLAIN = "text/plain";

    var appendABViewSupported;
    try {
        appendABViewSupported = new Blob([new DataView(new ArrayBuffer(0))]).size === 0;
    } catch (e) {}

    function Crc32() {
        this.crc = -1;
    }
    Crc32.prototype.append = function append(data) {
        var crc = this.crc | 0,
            table = this.table;
        for (var offset = 0, len = data.length | 0; offset < len; offset++)
            crc = (crc >>> 8) ^ table[(crc ^ data[offset]) & 0xFF];
        this.crc = crc;
    };
    Crc32.prototype.get = function get() {
        return~ this.crc;
    };
    Crc32.prototype.table = (function() {
        var i, j, t, table = []; // Uint32Array is actually slower than []
        for (i = 0; i < 256; i++) {
            t = i;
            for (j = 0; j < 8; j++)
                if (t & 1)
                    t = (t >>> 1) ^ 0xEDB88320;
                else
                    t = t >>> 1;
            table[i] = t;
        }
        return table;
    })();

    // "no-op" codec

    function NOOP() {}
    NOOP.prototype.append = function append(bytes, onprogress) {
        return bytes;
    };
    NOOP.prototype.flush = function flush() {};

    function blobSlice(blob, index, length) {
        if (index < 0 || length < 0 || index + length > blob.size)
            throw new RangeError('offset:' + index + ', length:' + length + ', size:' + blob.size);
        if (blob.slice)
            return blob.slice(index, index + length);
        else if (blob.webkitSlice)
            return blob.webkitSlice(index, index + length);
        else if (blob.mozSlice)
            return blob.mozSlice(index, index + length);
        else if (blob.msSlice)
            return blob.msSlice(index, index + length);
    }

    function getDataHelper(byteLength, bytes) {
        var dataBuffer, dataArray;
        dataBuffer = new ArrayBuffer(byteLength);
        dataArray = new Uint8Array(dataBuffer);
        if (bytes)
            dataArray.set(bytes, 0);
        return {
            buffer: dataBuffer,
            array: dataArray,
            view: new DataView(dataBuffer)
        };
    }

    // Readers

    function Reader() {}

    function TextReader(text) {
        var that = this,
            blobReader;

        function init(callback, onerror) {
            var blob = new Blob([text], {
                type: TEXT_PLAIN
            });
            blobReader = new BlobReader(blob);
            blobReader.init(function() {
                that.size = blobReader.size;
                callback();
            }, onerror);
        }

        function readUint8Array(index, length, callback, onerror) {
            blobReader.readUint8Array(index, length, callback, onerror);
        }

        that.size = 0;
        that.init = init;
        that.readUint8Array = readUint8Array;
    }
    TextReader.prototype = new Reader();
    TextReader.prototype.constructor = TextReader;

    function Data64URIReader(dataURI) {
        var that = this,
            dataStart;

        function init(callback) {
            var dataEnd = dataURI.length;
            while (dataURI.charAt(dataEnd - 1) == "=")
                dataEnd--;
            dataStart = dataURI.indexOf(",") + 1;
            that.size = Math.floor((dataEnd - dataStart) * 0.75);
            callback();
        }

        function readUint8Array(index, length, callback) {
            var i, data = getDataHelper(length);
            var start = Math.floor(index / 3) * 4;
            var end = Math.ceil((index + length) / 3) * 4;
            var bytes = obj.atob(dataURI.substring(start + dataStart, end + dataStart));
            var delta = index - Math.floor(start / 4) * 3;
            for (i = delta; i < delta + length; i++)
                data.array[i - delta] = bytes.charCodeAt(i);
            callback(data.array);
        }

        that.size = 0;
        that.init = init;
        that.readUint8Array = readUint8Array;
    }
    Data64URIReader.prototype = new Reader();
    Data64URIReader.prototype.constructor = Data64URIReader;

    function BlobReader(blob) {
        var that = this;

        function init(callback) {
            that.size = blob.size;
            callback();
        }

        function readUint8Array(index, length, callback, onerror) {
            var reader = new FileReader();
            reader.onload = function(e) {
                callback(new Uint8Array(e.target.result));
            };
            reader.onerror = onerror;
            try {
                reader.readAsArrayBuffer(blobSlice(blob, index, length));
            } catch (e) {
                onerror(e);
            }
        }

        that.size = 0;
        that.init = init;
        that.readUint8Array = readUint8Array;
    }
    BlobReader.prototype = new Reader();
    BlobReader.prototype.constructor = BlobReader;

    // Writers

    function Writer() {}
    Writer.prototype.getData = function(callback) {
        callback(this.data);
    };

    function TextWriter(encoding) {
        var that = this,
            blob;

        function init(callback) {
            blob = new Blob([], {
                type: TEXT_PLAIN
            });
            callback();
        }

        function writeUint8Array(array, callback) {
            blob = new Blob([blob, appendABViewSupported ? array : array.buffer], {
                type: TEXT_PLAIN
            });
            callback();
        }

        function getData(callback, onerror) {
            var reader = new FileReader();
            reader.onload = function(e) {
                callback(e.target.result);
            };
            reader.onerror = onerror;
            reader.readAsText(blob, encoding);
        }

        that.init = init;
        that.writeUint8Array = writeUint8Array;
        that.getData = getData;
    }
    TextWriter.prototype = new Writer();
    TextWriter.prototype.constructor = TextWriter;

    function Data64URIWriter(contentType) {
        var that = this,
            data = "",
            pending = "";

        function init(callback) {
            data += "data:" + (contentType || "") + ";base64,";
            callback();
        }

        function writeUint8Array(array, callback) {
            var i, delta = pending.length,
                dataString = pending;
            pending = "";
            for (i = 0; i < (Math.floor((delta + array.length) / 3) * 3) - delta; i++)
                dataString += String.fromCharCode(array[i]);
            for (; i < array.length; i++)
                pending += String.fromCharCode(array[i]);
            if (dataString.length > 2)
                data += obj.btoa(dataString);
            else
                pending = dataString;
            callback();
        }

        function getData(callback) {
            callback(data + obj.btoa(pending));
        }

        that.init = init;
        that.writeUint8Array = writeUint8Array;
        that.getData = getData;
    }
    Data64URIWriter.prototype = new Writer();
    Data64URIWriter.prototype.constructor = Data64URIWriter;

    function BlobWriter(contentType) {
        var blob, that = this;

        function init(callback) {
            blob = new Blob([], {
                type: contentType
            });
            callback();
        }

        function writeUint8Array(array, callback) {
            blob = new Blob([blob, appendABViewSupported ? array : array.buffer], {
                type: contentType
            });
            callback();
        }

        function getData(callback) {
            callback(blob);
        }

        that.init = init;
        that.writeUint8Array = writeUint8Array;
        that.getData = getData;
    }
    BlobWriter.prototype = new Writer();
    BlobWriter.prototype.constructor = BlobWriter;

    /** 
     * inflate/deflate core functions
     * @param worker {Worker} web worker for the task.
     * @param initialMessage {Object} initial message to be sent to the worker. should contain
     *   sn(serial number for distinguishing multiple tasks sent to the worker), and codecClass.
     *   This function may add more properties before sending.
     */

    function launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror) {
        var chunkIndex = 0,
            index, outputSize, sn = initialMessage.sn,
            crc;

        function onflush() {
            worker.removeEventListener('message', onmessage, false);
            onend(outputSize, crc);
        }

        function onmessage(event) {
            var message = event.data,
                data = message.data,
                err = message.error;
            if (err) {
                err.toString = function() {
                    return 'Error: ' + this.message;
                };
                onreaderror(err);
                return;
            }
            if (message.sn !== sn)
                return;
            if (typeof message.codecTime === 'number')
                worker.codecTime += message.codecTime; // should be before onflush()
            if (typeof message.crcTime === 'number')
                worker.crcTime += message.crcTime;

            switch (message.type) {
                case 'append':
                    if (data) {
                        outputSize += data.length;
                        writer.writeUint8Array(data, function() {
                            step();
                        }, onwriteerror);
                    } else
                        step();
                    break;
                case 'flush':
                    crc = message.crc;
                    if (data) {
                        outputSize += data.length;
                        writer.writeUint8Array(data, function() {
                            onflush();
                        }, onwriteerror);
                    } else
                        onflush();
                    break;
                case 'progress':
                    if (onprogress)
                        onprogress(index + message.loaded, size);
                    break;
                case 'importScripts': //no need to handle here
                case 'newTask':
                case 'echo':
                    break;
                default:
                    console.warn('zip.js:launchWorkerProcess: unknown message: ', message);
            }
        }

        function step() {
            index = chunkIndex * CHUNK_SIZE;
            if (index < size) {
                reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(array) {
                    if (onprogress)
                        onprogress(index, size);
                    var msg = index === 0 ? initialMessage : {
                        sn: sn
                    };
                    msg.type = 'append';
                    msg.data = array;
                    worker.postMessage(msg, [array.buffer]);
                    chunkIndex++;
                }, onreaderror);
            } else {
                worker.postMessage({
                    sn: sn,
                    type: 'flush'
                });
            }
        }

        outputSize = 0;
        worker.addEventListener('message', onmessage, false);
        step();
    }

    function launchProcess(process, reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror) {
        var chunkIndex = 0,
            index, outputSize = 0,
            crcInput = crcType === 'input',
            crcOutput = crcType === 'output',
            crc = new Crc32();

        function step() {
            var outputData;
            index = chunkIndex * CHUNK_SIZE;
            if (index < size)
                reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(inputData) {
                    var outputData;
                    try {
                        outputData = process.append(inputData, function(loaded) {
                            if (onprogress)
                                onprogress(index + loaded, size);
                        });
                    } catch (e) {
                        onreaderror(e);
                        return;
                    }
                    if (outputData) {
                        outputSize += outputData.length;
                        writer.writeUint8Array(outputData, function() {
                            chunkIndex++;
                            setTimeout(step, 1);
                        }, onwriteerror);
                        if (crcOutput)
                            crc.append(outputData);
                    } else {
                        chunkIndex++;
                        setTimeout(step, 1);
                    }
                    if (crcInput)
                        crc.append(inputData);
                    if (onprogress)
                        onprogress(index, size);
                }, onreaderror);
            else {
                try {
                    outputData = process.flush();
                } catch (e) {
                    onreaderror(e);
                    return;
                }
                if (outputData) {
                    if (crcOutput)
                        crc.append(outputData);
                    outputSize += outputData.length;
                    writer.writeUint8Array(outputData, function() {
                        onend(outputSize, crc.get());
                    }, onwriteerror);
                } else
                    onend(outputSize, crc.get());
            }
        }

        step();
    }

    function inflate(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
        var crcType = computeCrc32 ? 'output' : 'none';
        if (obj.zip.useWebWorkers) {
            var initialMessage = {
                sn: sn,
                codecClass: 'Inflater',
                crcType: crcType,
            };
            launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);
        } else
            launchProcess(new obj.zip.Inflater(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror);
    }

    function deflate(worker, sn, reader, writer, level, onend, onprogress, onreaderror, onwriteerror) {
        var crcType = 'input';
        if (obj.zip.useWebWorkers) {
            var initialMessage = {
                sn: sn,
                options: {
                    level: level
                },
                codecClass: 'Deflater',
                crcType: crcType,
            };
            launchWorkerProcess(worker, initialMessage, reader, writer, 0, reader.size, onprogress, onend, onreaderror, onwriteerror);
        } else
            launchProcess(new obj.zip.Deflater(), reader, writer, 0, reader.size, crcType, onprogress, onend, onreaderror, onwriteerror);
    }

    function copy(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
        var crcType = 'input';
        if (obj.zip.useWebWorkers && computeCrc32) {
            var initialMessage = {
                sn: sn,
                codecClass: 'NOOP',
                crcType: crcType,
            };
            launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);
        } else
            launchProcess(new NOOP(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror);
    }

    // ZipReader

    function decodeASCII(str) {
        var i, out = "",
            charCode, extendedASCII = ['\u00C7', '\u00FC', '\u00E9', '\u00E2', '\u00E4', '\u00E0', '\u00E5', '\u00E7', '\u00EA', '\u00EB',
                '\u00E8', '\u00EF', '\u00EE', '\u00EC', '\u00C4', '\u00C5', '\u00C9', '\u00E6', '\u00C6', '\u00F4', '\u00F6', '\u00F2', '\u00FB', '\u00F9',
                '\u00FF', '\u00D6', '\u00DC', '\u00F8', '\u00A3', '\u00D8', '\u00D7', '\u0192', '\u00E1', '\u00ED', '\u00F3', '\u00FA', '\u00F1', '\u00D1',
                '\u00AA', '\u00BA', '\u00BF', '\u00AE', '\u00AC', '\u00BD', '\u00BC', '\u00A1', '\u00AB', '\u00BB', '_', '_', '_', '\u00A6', '\u00A6',
                '\u00C1', '\u00C2', '\u00C0', '\u00A9', '\u00A6', '\u00A6', '+', '+', '\u00A2', '\u00A5', '+', '+', '-', '-', '+', '-', '+', '\u00E3',
                '\u00C3', '+', '+', '-', '-', '\u00A6', '-', '+', '\u00A4', '\u00F0', '\u00D0', '\u00CA', '\u00CB', '\u00C8', 'i', '\u00CD', '\u00CE',
                '\u00CF', '+', '+', '_', '_', '\u00A6', '\u00CC', '_', '\u00D3', '\u00DF', '\u00D4', '\u00D2', '\u00F5', '\u00D5', '\u00B5', '\u00FE',
                '\u00DE', '\u00DA', '\u00DB', '\u00D9', '\u00FD', '\u00DD', '\u00AF', '\u00B4', '\u00AD', '\u00B1', '_', '\u00BE', '\u00B6', '\u00A7',
                '\u00F7', '\u00B8', '\u00B0', '\u00A8', '\u00B7', '\u00B9', '\u00B3', '\u00B2', '_', ' '
            ];
        for (i = 0; i < str.length; i++) {
            charCode = str.charCodeAt(i) & 0xFF;
            if (charCode > 127)
                out += extendedASCII[charCode - 128];
            else
                out += String.fromCharCode(charCode);
        }
        return out;
    }

    function decodeUTF8(string) {
        return decodeURIComponent(escape(string));
    }

    function getString(bytes) {
        var i, str = "";
        for (i = 0; i < bytes.length; i++)
            str += String.fromCharCode(bytes[i]);
        return str;
    }

    function getDate(timeRaw) {
        var date = (timeRaw & 0xffff0000) >> 16,
            time = timeRaw & 0x0000ffff;
        try {
            return new Date(1980 + ((date & 0xFE00) >> 9), ((date & 0x01E0) >> 5) - 1, date & 0x001F, (time & 0xF800) >> 11, (time & 0x07E0) >> 5, (time & 0x001F) * 2, 0);
        } catch (e) {}
    }

    function readCommonHeader(entry, data, index, centralDirectory, onerror) {
        entry.version = data.view.getUint16(index, true);
        entry.bitFlag = data.view.getUint16(index + 2, true);
        entry.compressionMethod = data.view.getUint16(index + 4, true);
        entry.lastModDateRaw = data.view.getUint32(index + 6, true);
        entry.lastModDate = getDate(entry.lastModDateRaw);
        if ((entry.bitFlag & 0x01) === 0x01) {
            onerror(ERR_ENCRYPTED);
            return;
        }
        if (centralDirectory || (entry.bitFlag & 0x0008) != 0x0008) {
            entry.crc32 = data.view.getUint32(index + 10, true);
            entry.compressedSize = data.view.getUint32(index + 14, true);
            entry.uncompressedSize = data.view.getUint32(index + 18, true);
        }
        if (entry.compressedSize === 0xFFFFFFFF || entry.uncompressedSize === 0xFFFFFFFF) {
            onerror(ERR_ZIP64);
            return;
        }
        entry.filenameLength = data.view.getUint16(index + 22, true);
        entry.extraFieldLength = data.view.getUint16(index + 24, true);
    }

    function createZipReader(reader, callback, onerror) {
        var inflateSN = 0;

        function Entry() {}

        Entry.prototype.getData = function(writer, onend, onprogress, checkCrc32) {
            var that = this;

            function testCrc32(crc32) {
                var dataCrc32 = getDataHelper(4);
                dataCrc32.view.setUint32(0, crc32);
                return that.crc32 == dataCrc32.view.getUint32(0);
            }

            function getWriterData(uncompressedSize, crc32) {
                if (checkCrc32 && !testCrc32(crc32))
                    onerror(ERR_CRC);
                else
                    writer.getData(function(data) {
                        onend(data);
                    });
            }

            function onreaderror(err) {
                onerror(err || ERR_READ_DATA);
            }

            function onwriteerror(err) {
                onerror(err || ERR_WRITE_DATA);
            }

            reader.readUint8Array(that.offset, 30, function(bytes) {
                var data = getDataHelper(bytes.length, bytes),
                    dataOffset;
                if (data.view.getUint32(0) != 0x504b0304) {
                    onerror(ERR_BAD_FORMAT);
                    return;
                }
                readCommonHeader(that, data, 4, false, onerror);
                dataOffset = that.offset + 30 + that.filenameLength + that.extraFieldLength;
                writer.init(function() {
                    if (that.compressionMethod === 0)
                        copy(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);
                    else
                        inflate(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);
                }, onwriteerror);
            }, onreaderror);
        };

        function seekEOCDR(eocdrCallback) {
            // "End of central directory record" is the last part of a zip archive, and is at least 22 bytes long.
            // Zip file comment is the last part of EOCDR and has max length of 64KB,
            // so we only have to search the last 64K + 22 bytes of a archive for EOCDR signature (0x06054b50).
            var EOCDR_MIN = 22;
            if (reader.size < EOCDR_MIN) {
                onerror(ERR_BAD_FORMAT);
                return;
            }
            var ZIP_COMMENT_MAX = 256 * 256,
                EOCDR_MAX = EOCDR_MIN + ZIP_COMMENT_MAX;

            // In most cases, the EOCDR is EOCDR_MIN bytes long
            doSeek(EOCDR_MIN, function() {
                // If not found, try within EOCDR_MAX bytes
                doSeek(Math.min(EOCDR_MAX, reader.size), function() {
                    onerror(ERR_BAD_FORMAT);
                });
            });

            // seek last length bytes of file for EOCDR

            function doSeek(length, eocdrNotFoundCallback) {
                reader.readUint8Array(reader.size - length, length, function(bytes) {
                    for (var i = bytes.length - EOCDR_MIN; i >= 0; i--) {
                        if (bytes[i] === 0x50 && bytes[i + 1] === 0x4b && bytes[i + 2] === 0x05 && bytes[i + 3] === 0x06) {
                            eocdrCallback(new DataView(bytes.buffer, i, EOCDR_MIN));
                            return;
                        }
                    }
                    eocdrNotFoundCallback();
                }, function() {
                    onerror(ERR_READ);
                });
            }
        }

        var zipReader = {
            getEntries: function(callback) {
                var worker = this._worker;
                // look for End of central directory record
                seekEOCDR(function(dataView) {
                    var datalength, fileslength;
                    datalength = dataView.getUint32(16, true);
                    fileslength = dataView.getUint16(8, true);
                    if (datalength < 0 || datalength >= reader.size) {
                        onerror(ERR_BAD_FORMAT);
                        return;
                    }
                    reader.readUint8Array(datalength, reader.size - datalength, function(bytes) {
                        var i, index = 0,
                            entries = [],
                            entry, filename, comment, data = getDataHelper(bytes.length, bytes);
                        for (i = 0; i < fileslength; i++) {
                            entry = new Entry();
                            entry._worker = worker;
                            if (data.view.getUint32(index) != 0x504b0102) {
                                onerror(ERR_BAD_FORMAT);
                                return;
                            }
                            readCommonHeader(entry, data, index + 6, true, onerror);
                            entry.commentLength = data.view.getUint16(index + 32, true);
                            entry.directory = ((data.view.getUint8(index + 38) & 0x10) == 0x10);
                            entry.offset = data.view.getUint32(index + 42, true);
                            filename = getString(data.array.subarray(index + 46, index + 46 + entry.filenameLength));
                            entry.filename = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(filename) : decodeASCII(filename);
                            if (!entry.directory && entry.filename.charAt(entry.filename.length - 1) == "/")
                                entry.directory = true;
                            comment = getString(data.array.subarray(index + 46 + entry.filenameLength + entry.extraFieldLength, index + 46 + entry.filenameLength + entry.extraFieldLength + entry.commentLength));
                            entry.comment = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(comment) : decodeASCII(comment);
                            entries.push(entry);
                            index += 46 + entry.filenameLength + entry.extraFieldLength + entry.commentLength;
                        }
                        callback(entries);
                    }, function() {
                        onerror(ERR_READ);
                    });
                });
            },
            close: function(callback) {
                if (this._worker) {
                    this._worker.terminate();
                    this._worker = null;
                }
                if (callback)
                    callback();
            },
            _worker: null
        };

        if (!obj.zip.useWebWorkers)
            callback(zipReader);
        else {
            createWorker('inflater',
                function(worker) {
                    zipReader._worker = worker;
                    callback(zipReader);
                },
                function(err) {
                    onerror(err);
                }
            );
        }
    }

    // ZipWriter

    function encodeUTF8(string) {
        return unescape(encodeURIComponent(string));
    }

    function getBytes(str) {
        var i, array = [];
        for (i = 0; i < str.length; i++)
            array.push(str.charCodeAt(i));
        return array;
    }

    function createZipWriter(writer, callback, onerror, dontDeflate) {
        var files = {}, filenames = [],
            datalength = 0;
        var deflateSN = 0;

        function onwriteerror(err) {
            onerror(err || ERR_WRITE);
        }

        function onreaderror(err) {
            onerror(err || ERR_READ_DATA);
        }

        var zipWriter = {
            add: function(name, reader, onend, onprogress, options) {
                var header, filename, date;
                var worker = this._worker;

                function writeHeader(callback) {
                    var data;
                    date = options.lastModDate || new Date();
                    header = getDataHelper(26);
                    files[name] = {
                        headerArray: header.array,
                        directory: options.directory,
                        filename: filename,
                        offset: datalength,
                        comment: getBytes(encodeUTF8(options.comment || ""))
                    };
                    header.view.setUint32(0, 0x14000808);
                    if (options.version)
                        header.view.setUint8(0, options.version);
                    if (!dontDeflate && options.level !== 0 && !options.directory)
                        header.view.setUint16(4, 0x0800);
                    header.view.setUint16(6, (((date.getHours() << 6) | date.getMinutes()) << 5) | date.getSeconds() / 2, true);
                    header.view.setUint16(8, ((((date.getFullYear() - 1980) << 4) | (date.getMonth() + 1)) << 5) | date.getDate(), true);
                    header.view.setUint16(22, filename.length, true);
                    data = getDataHelper(30 + filename.length);
                    data.view.setUint32(0, 0x504b0304);
                    data.array.set(header.array, 4);
                    data.array.set(filename, 30);
                    datalength += data.array.length;
                    writer.writeUint8Array(data.array, callback, onwriteerror);
                }

                function writeFooter(compressedLength, crc32) {
                    var footer = getDataHelper(16);
                    datalength += compressedLength || 0;
                    footer.view.setUint32(0, 0x504b0708);
                    if (typeof crc32 != "undefined") {
                        header.view.setUint32(10, crc32, true);
                        footer.view.setUint32(4, crc32, true);
                    }
                    if (reader) {
                        footer.view.setUint32(8, compressedLength, true);
                        header.view.setUint32(14, compressedLength, true);
                        footer.view.setUint32(12, reader.size, true);
                        header.view.setUint32(18, reader.size, true);
                    }
                    writer.writeUint8Array(footer.array, function() {
                        datalength += 16;
                        onend();
                    }, onwriteerror);
                }

                function writeFile() {
                    options = options || {};
                    name = name.trim();
                    if (options.directory && name.charAt(name.length - 1) != "/")
                        name += "/";
                    if (files.hasOwnProperty(name)) {
                        onerror(ERR_DUPLICATED_NAME);
                        return;
                    }
                    filename = getBytes(encodeUTF8(name));
                    filenames.push(name);
                    writeHeader(function() {
                        if (reader)
                            if (dontDeflate || options.level === 0)
                                copy(worker, deflateSN++, reader, writer, 0, reader.size, true, writeFooter, onprogress, onreaderror, onwriteerror);
                            else
                                deflate(worker, deflateSN++, reader, writer, options.level, writeFooter, onprogress, onreaderror, onwriteerror);
                            else
                                writeFooter();
                    }, onwriteerror);
                }

                if (reader)
                    reader.init(writeFile, onreaderror);
                else
                    writeFile();
            },
            close: function(callback) {
                if (this._worker) {
                    this._worker.terminate();
                    this._worker = null;
                }

                var data, length = 0,
                    index = 0,
                    indexFilename, file;
                for (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {
                    file = files[filenames[indexFilename]];
                    length += 46 + file.filename.length + file.comment.length;
                }
                data = getDataHelper(length + 22);
                for (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {
                    file = files[filenames[indexFilename]];
                    data.view.setUint32(index, 0x504b0102);
                    data.view.setUint16(index + 4, 0x1400);
                    data.array.set(file.headerArray, index + 6);
                    data.view.setUint16(index + 32, file.comment.length, true);
                    if (file.directory)
                        data.view.setUint8(index + 38, 0x10);
                    data.view.setUint32(index + 42, file.offset, true);
                    data.array.set(file.filename, index + 46);
                    data.array.set(file.comment, index + 46 + file.filename.length);
                    index += 46 + file.filename.length + file.comment.length;
                }
                data.view.setUint32(index, 0x504b0506);
                data.view.setUint16(index + 8, filenames.length, true);
                data.view.setUint16(index + 10, filenames.length, true);
                data.view.setUint32(index + 12, length, true);
                data.view.setUint32(index + 16, datalength, true);
                writer.writeUint8Array(data.array, function() {
                    writer.getData(callback);
                }, onwriteerror);
            },
            _worker: null
        };

        if (!obj.zip.useWebWorkers)
            callback(zipWriter);
        else {
            createWorker('deflater',
                function(worker) {
                    zipWriter._worker = worker;
                    callback(zipWriter);
                },
                function(err) {
                    onerror(err);
                }
            );
        }
    }

    function resolveURLs(urls) {
        var a = document.createElement('a');
        return urls.map(function(url) {
            a.href = url;
            return a.href;
        });
    }

    var DEFAULT_WORKER_SCRIPTS = {
        deflater: ['z-worker.js', 'deflate.js'],
        inflater: ['z-worker.js', 'inflate.js']
    };

    function createWorker(type, callback, onerror) {
        if (obj.zip.workerScripts !== null && obj.zip.workerScriptsPath !== null) {
            onerror(new Error('Either zip.workerScripts or zip.workerScriptsPath may be set, not both.'));
            return;
        }
        var scripts;
        if (obj.zip.workerScripts) {
            scripts = obj.zip.workerScripts[type];
            if (!Array.isArray(scripts)) {
                onerror(new Error('zip.workerScripts.' + type + ' is not an array!'));
                return;
            }
            scripts = resolveURLs(scripts);
        } else {
            scripts = DEFAULT_WORKER_SCRIPTS[type].slice(0);
            scripts[0] = (obj.zip.workerScriptsPath || '') + scripts[0];
        }
        var worker = new Worker(scripts[0]);
        // record total consumed time by inflater/deflater/crc32 in this worker
        worker.codecTime = worker.crcTime = 0;
        worker.postMessage({
            type: 'importScripts',
            scripts: scripts.slice(1)
        });
        worker.addEventListener('message', onmessage);

        function onmessage(ev) {
            var msg = ev.data;
            if (msg.error) {
                worker.terminate(); // should before onerror(), because onerror() may throw.
                onerror(msg.error);
                return;
            }
            if (msg.type === 'importScripts') {
                worker.removeEventListener('message', onmessage);
                worker.removeEventListener('error', errorHandler);
                callback(worker);
            }
        }
        // catch entry script loading error and other unhandled errors
        worker.addEventListener('error', errorHandler);

        function errorHandler(err) {
            worker.terminate();
            onerror(err);
        }
    }

    function onerror_default(error) {
        console.error(error);
    }
    obj.zip = {
        Reader: Reader,
        Writer: Writer,
        BlobReader: BlobReader,
        Data64URIReader: Data64URIReader,
        TextReader: TextReader,
        BlobWriter: BlobWriter,
        Data64URIWriter: Data64URIWriter,
        TextWriter: TextWriter,
        createReader: function(reader, callback, onerror) {
            onerror = onerror || onerror_default;

            reader.init(function() {
                createZipReader(reader, callback, onerror);
            }, onerror);
        },
        createWriter: function(writer, callback, onerror, dontDeflate) {
            onerror = onerror || onerror_default;
            dontDeflate = !! dontDeflate;

            writer.init(function() {
                createZipWriter(writer, callback, onerror, dontDeflate);
            }, onerror);
        },
        useWebWorkers: true,
        /**
         * Directory containing the default worker scripts (z-worker.js, deflate.js, and inflate.js), relative to current base url.
         * E.g.: zip.workerScripts = './';
         */
        workerScriptsPath: null,
        /**
         * Advanced option to control which scripts are loaded in the Web worker. If this option is specified, then workerScriptsPath must not be set.
         * workerScripts.deflater/workerScripts.inflater should be arrays of urls to scripts for deflater/inflater, respectively.
         * Scripts in the array are executed in order, and the first one should be z-worker.js, which is used to start the worker.
         * All urls are relative to current base url.
         * E.g.:
         * zip.workerScripts = {
         *   deflater: ['z-worker.js', 'deflate.js'],
         *   inflater: ['z-worker.js', 'inflate.js']
         * };
         */
        workerScripts: null,
    };

})(this);
/*
    This app has been copied from https://github.com/wrackzone/project-kilo/tree/master/portfolio-timesheet-export and modified to fit TS Template.
*/

var app = null;

Ext.define('PTApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    stateful: true,
    id: 'app',
    cache: [],
    config: {
        defaultSettings: {
            extApplicationValue:'RALLY',
            extApplication:true
        }
    },
    getSettingsFields: function() {
        var me = this;

        return  [
            {
                name: 'extApplication',
                xtype: 'rallycheckboxfield',
                boxLabelAlign: 'after',
                fieldLabel: '',
                margin: 25,
                boxLabel: 'Include &lt;EXTAPPLICATION&gt;RALLY&lt;/EXTAPPLICATION&gt; to all records in the E1BPCATS1.xml file.'
            },
            {
                name: 'extApplicationValue',
                xtype: 'textfield',
                fieldLabel: '&lt;EXTAPPLICATION/&gt; tag Value',
                labelWidth: 125,
                labelAlign: 'left',
                minWidth: 200,
                margin: 25
            }];
    },
    items: [{
        id: 'panel',
        xtype: 'panel',
        layout: 'column',
        items: [{
            name: 'intervalType',
            xtype: 'combo',
            store: Ext.create("Ext.data.ArrayStore", {
                fields: ['interval'],
                data: [
                    ['Today'],
                    ['This Week'],
                    ['Last Week'],
                    ['This Month'],
                    ['Last Month']
                ]
            }),
            valueField: 'interval',
            displayField: 'interval',
            queryMode: 'local',
            forceSelection: true,
            boxLabelAlign: 'after',
            fieldLabel: 'Interval',
            margin: '5 5 5 5',
            listeners: {
                scope: this,
                select: function(list, item) {
                    var startDateCmp = Ext.getCmp('startDate');
                    var endDateCmp = Ext.getCmp('endDate');
                    var start, end;

                    var dt = new Date();

                    switch (_.first(item).get('interval')) {
                        case 'Today':
                            start = Ext.Date.clearTime(dt);
                            end = Ext.Date.clearTime(Ext.Date.add(start, Ext.Date.MILLI, ((24 * 60 * 60 * 1000) - 1)));
                            break;
                        case 'This Week':
                            start = Ext.Date.clearTime(Ext.Date.subtract(dt, Ext.Date.DAY, (dt.getDay()-1))); //Monday AM - WAS:Sunday AM
                            end = Ext.Date.clearTime(Ext.Date.add(start, Ext.Date.MILLI, ((6 * 24 * 60 * 60 * 1000)))); //Sunday PM WAS:Saturday PM
                            break;
                        case 'Last Week':
                            start = Ext.Date.clearTime(Ext.Date.subtract(dt, Ext.Date.DAY, 7 + (dt.getDay()-1))); //Monday AM - WAS:Sunday AM
                            end = Ext.Date.clearTime(Ext.Date.add(start, Ext.Date.MILLI, ((6 * 24 * 60 * 60 * 1000)))); //Sunday PM WAS:Saturday PM
                            break;
                        case 'This Month':
                            start = new Date((dt.getMonth() + 1) + "/1/" + dt.getFullYear());//new Date("1/" + dt.getMonth() + 1 + "/" + dt.getFullYear());
                            end = Ext.Date.subtract(Ext.Date.add(start, Ext.Date.MONTH, 1), Ext.Date.MILLI, 1);
                            break;
                        case 'Last Month':
                            start = new Date((dt.getMonth() + 1) + "/1/" + dt.getFullYear());//new Date("1/" + dt.getMonth() + 1 + "/" + dt.getFullYear());
                            start = Ext.Date.subtract(start, Ext.Date.MONTH, 1);
                            end = Ext.Date.subtract(Ext.Date.add(start, Ext.Date.MONTH, 1), Ext.Date.MILLI, 1);
                            break;
                    }

                    startDateCmp.setValue(start);
                    startDateCmp.getValue();
                    endDateCmp.setValue(end);
                    endDateCmp.getValue();
                    app.createTimeValueStore();
                }
            }
        }, {
            id: 'startDate',
            margin: '5 5 5 5',
            xtype: 'datefield',
            format: 'd M Y',
            stateful: true,
            stateId: 'tsDate1',
            fieldLabel: 'Start Date',
            value: new Date(),
            listeners: {
                select: function(field, value) {
                    var endDateCmp = Ext.getCmp('endDate');
                    if (endDateCmp.getValue() < value) {
                        endDateCmp.setValue(value);
                    }
                    app.createTimeValueStore();
                }
            }
        }, {
            id: 'endDate',
            margin: '5 5 5 5',
            xtype: 'datefield',
            stateful: true,
            stateId: 'tsDate2',
            format: 'd M Y',
            fieldLabel: 'End Date',
            value: new Date(),
            listeners: {
                select: function(field, value) {
                    var startDateCmp = Ext.getCmp('startDate');
                    if (startDateCmp.getValue() > value) {
                        startDateCmp.setValue(value);
                    }
                    app.createTimeValueStore();
                }
            }
        },
        {
            name: 'projectFilter',
            id: 'projectFilter',
            xtype: 'rallycheckboxfield',
            boxLabelAlign: 'before',
            fieldLabel: '',
            margin: '5 5 5 5',
            boxLabel: 'Use Project Filter',
            value: true,
            listeners: {
                change: function(field, value) {
                    app.createTimeValueStore();
                }
            }
        },
        {
            id: 'exportButton',
            margin: '5 5 5 5',
            xtype: 'rallybutton',
            text: 'Export',
            handler: function() {
                var saveDialog = Ext.create('Rally.ui.dialog.Dialog', {
                    autoShow: true,
                    draggable: true,
                    width: 300,
                    title: 'Export all records',
                    items: [{
                            xtype: 'rallybutton',
                            text: 'CSV',
                            handler: function() {
                                app.exporter.exportCSV(app.grid);
                                saveDialog.destroy();
                            }
                        }, {
                            xtype: 'rallybutton',
                            text: 'SAP XML',
                            handler: function() {
                                app.exporter.exportSAPXML(app.grid,{'extApplication':app.getSetting('extApplication'),'extApplicationValue':app.getSetting('extApplicationValue')});
                                saveDialog.destroy();
                            }
                        },

                        {
                            xtype: 'rallybutton',
                            text: 'Cancel',
                            handler: function() {
                                Ext.destroy(saveDialog);
                            },
                            flex: 1
                        }
                    ]

                });
            }
        }]
    },
    {
        xtype: 'panel',
        itemId: 'filterPanel',
        layout: {
                type: 'hbox'
            },
        border:1
    }
    ],

    launch: function() {

        app = this;

        this._onLoad();
    },

    _onLoad: function() {

        app._loadAStoreWithAPromise(
                'TypeDefinition',
                true, [{
                    property: "Ordinal",
                    operator: "!=",
                    value: -1
                }])
            .then({
                success: function(records) {
                    app.piTypes = records;
                    console.log("pitypes:", records);
                    app.exporter = Ext.create("GridExporter");
                    app.createTimeValueStore();
                }
            });
    },

    createTimeValueStore: function() {

        app.showMask("Loading Time Sheet Values");

        // clear the grid
        if (!_.isNull(app.grid)) {
            app.remove(app.grid);
        }

        var nr = null;
        if ((nr = Ext.getCmp('noRecords'))) {
            nr.destroy();
        }

        var filter = app._getDateFilter();

        // exclude zero value items
        filter.push({
            property: 'Hours',
            operator: '>',
            value: 0
        });

        var filters = Rally.data.wsapi.Filter.and(filter);
        //console.log(filter);
        //check if  c_KMDTimeregistrationIntegration on project is not "No".
        var integFilter = [];
        if(Ext.getCmp('projectFilter').getValue()){
            integFilter = Rally.data.wsapi.Filter.or([{
                        property: 'TimeEntryItem.Project.c_KMDTimeregistrationIntegration',
                        value: 'Yes'
                    },
                    {
                        property: 'TimeEntryItem.Project.c_KMDTimeregistrationIntegration',
                        value: 'Yes with suboperation substitution'
                    }]);
            filters = filters.and(integFilter);
        }


        Ext.create('Rally.data.wsapi.Store', {
            model: "TimeEntryValue",
            //fetch: true,
            fetch: [
                    "Name",
                    "FormattedID",
                    "TimeEntryItem",
                    "TimeEntryValueObject",
                    "TimeEntryItemObject",
                    "User",
                    "UserObject",
                    "WorkProduct",
                    "Requirement",
                    "Parent",
                    "PortfolioItem",
                    "Task",
                    "Artifact",
                    "Hierarchy",
                    "TypePath",
                    "_type",
                    "UserObject",
                    "UserName",
                    "TaskDisplayString",
                    "ProjectDisplayString",
                    "WorkProductDisplayString",
                    "c_SAPNetwork",
                    "c_SAPProject",
                    "c_SAPSubOperation",
                    "c_SAPOperation",
                    "Hours",
                    "ObjectID",
                    "DateVal",
                    "CreationDate",
                    "LastUpdated",
                    "c_KMDEmployeeID",
                    "Project",
                    "c_KMDTimeregistrationIntegration",
                    "Owner",
                    "EmailAddress",
                    "c_DefaultSAPSubOperation"
                    ],
            filters: filters,
            limit: 'Infinity'
        }).load({
            callback: function(records, operation, successful) {
                if (records.length === 0) {

                    app.hideMask();
                    app.add({
                        html: "No records for this date range",
                        itemId: "norecords",
                        id: "noRecords"
                    });
                }
                app.readRelatedValues(records,
                    function() {
                        app.hideMask();
                        var message = app.down("#norecords");
                        if (!_.isUndefined(message)) {
                            app.remove(message);
                        }
                        console.log('records', records);
                        app.createArrayStoreFromRecords(records);
                    }
                );
            }
        });
    },

    getFieldValue: function(record, field) {
        // returns the most specific value for a field
        // ie. Task -> Story -> Feature -> Epic
        var hasValue = function(value) {
            return !_.isUndefined(value) && !_.isNull(value) && value !== "";
        };
        var object = _.find(record.get("Hierarchy"), function(h) {
            return hasValue(h.get(field));
        });

        return (!_.isUndefined(object) && !_.isNull(object) ? object.get(field) : null);
    },

    getTypeFieldValue: function(record, type, field) {

        var object = _.find(record.get("Hierarchy"), function(h) {
            return h.get("_type") === type.get("TypePath").toLowerCase();
        });

        return (!_.isUndefined(object) && !_.isNull(object) ? object.get(field) : "");
    },

    createArrayStoreFromRecords: function(records) {

        var fields = [{
            displayName: 'User',
            name: 'UserName'
        }, {
            displayName: 'Task',
            name: 'TaskDisplayString'
        }, {
            displayName: 'Project',
            name: 'ProjectDisplayString'
        }, {
            displayName: 'Work Product',
            name: 'WorkProductDisplayString'
        }, {
            displayName: 'Feature ID',
            name: 'FeatureID'
        }, {
            displayName: 'Feature Title',
            name: 'FeatureName'
        }, {
            displayName: 'SAP Project',
            name: 'c_SAPProject'
        },{
            displayName: 'SAP Network',
            name: 'c_SAPNetwork'
        }, {
            displayName: 'SAP Operation',
            name: 'c_SAPOperation'
        }, {
            displayName: 'SAP Sub Operation',
            name: 'c_SAPSubOperation'
        }, {
            displayName: 'Epic ID',
            name: 'EpicID'
        }, {
            displayName: 'Epic Title',
            name: 'EpicName'
        }, {
            displayName: 'Hours Entered',
            name: 'Hours'
        }, {
            displayName: 'Unique ID',
            name: 'ObjectID'
        }, {
            displayName: 'Date',
            name: 'Date'
        }, {
            displayName: 'Updated',
            name: 'Updated'
        }, {
            displayName: 'Employee ID',
            name: 'c_KMDEmployeeID'
        }, {
            displayName: 'Hierarchy',
            name: 'Hierarchy'
        }];

        // convert records into a json data structure
        var data = _.map(records, function(r) {
            return {
                "UserName": r.get("UserObject").get("UserName"),
                "TaskDisplayString": r.get("TimeEntryItemObject").get("TaskDisplayString"),
                "ProjectDisplayString": r.get("TimeEntryItemObject").get("ProjectDisplayString"),
                "WorkProductDisplayString": r.get("TimeEntryItemObject").get("WorkProductDisplayString"),
                "FeatureID": app.getTypeFieldValue(r, app.piTypes[0], "FormattedID"),
                "FeatureName": app.getTypeFieldValue(r, app.piTypes[0], "Name"),
                'c_SAPProject': app.getFieldValue(r, 'c_SAPProject'),
                'c_SAPNetwork': app.getFieldValue(r, 'c_SAPNetwork'),
                'c_SAPOperation': app.getFieldValue(r, 'c_SAPOperation'),
                'c_SAPSubOperation': app.getSubOperationValue(r),
                'EpicID': app.getTypeFieldValue(r, app.piTypes[1], "FormattedID"),
                'EpicName': app.getTypeFieldValue(r, app.piTypes[1], "Name"),
                'Hours': r.get('Hours'),
                'ObjectID': r.get("ObjectID"),
                'Date': Ext.Date.format(r.get("DateVal"), "Ymd"),
                'Updated': Ext.Date.format(r.get("LastUpdated"), "Ymd H:i"),
                'c_KMDEmployeeID': r.get("UserObject").get("c_KMDEmployeeID"),
                'Hierarchy': r.get("Hierarchy"),
                'KMDTimeregistrationIntegration': r.get("TimeEntryProjectObject").get("c_KMDTimeregistrationIntegration"),
                'DefaultSAPSubOperation': r.get("UserObject").get("c_DefaultSAPSubOperation")
            };
        });

        console.log('data >>', data);

        var store = Ext.create('Ext.data.JsonStore', {
            fields: fields,
            data: data,
            // remoteFilter: false,
            // pageSize: 2000
            // ,
            statefulFilters:true
        });

        app.grid = new Ext.grid.GridPanel({
            header: false,
            id: 'tsGrid',
            title: 'TimeSheetData',
            store: store,
            stateful: true,
            stateId: 'tsGrid11',
            //plugins:[{ptype:"gridFilter"}],
            features: [{
                ftype: 'groupingsummary',
                showSummaryRow: true,
                groupHeaderTpl: ' {name}'
            }, {
                ftype: 'summary'
            }],
            columns: _.map(fields, function(f) {
                if (f.name === 'Hours') {
                    return {
                        text: f.displayName,
                        dataIndex: f.name,
                        summaryType: 'sum',
                        summaryRenderer: function(value, summaryData, dataIndex) {
                            return Ext.String.format('<div style="background-color:#E4EECF">Total: {0}</div>', value);
                        },
                        flex:1
                    };
                } else if (f.name === 'UserName') {
                    return {
                        text: f.displayName,
                        dataIndex: f.name,
                        // locked:true,
                        flex: 1,
                        summaryType: 'count',
                        summaryRenderer: function(value, summaryData, dataIndex) {
                            return Ext.String.format('<div style="background-color:#E4EECF"> {0} item{1}</div>', value, value > 1 ? 's' : '');
                        }
                    };
                } else if (f.name === 'TaskDisplayString' ||
                    f.name === 'WorkProductDisplayString' ||
                    f.name === "FeatureID" ||
                    f.name === "EpicID") {
                    return {
                        text: f.displayName,
                        dataIndex: f.name,
                        renderer: function(value, metaData, record, rowIdx, colIdx, store, view) {
                            return app.renderLink(value, record);
                        },
                        flex:1
                    };
                } else if (f.name === 'Hierarchy') {
                    return {
                        text: f.displayName,
                        dataIndex: f.name,
                        visible: false,
                        hidden: true,
                        flex:1
                    };
                } else
                    return {
                        text: f.displayName,
                        dataIndex: f.name,
                        flex:1
                    };
            })
        });


        var me = this;
        var fields_data = Ext.create('Ext.data.Store', {
            fields: ['name', 'displayName'],
            data : fields
        });

        var operator_data = Ext.create('Ext.data.Store', {
            fields: ['name', 'displayName'],
            data : [{
                        displayName: '<',
                        name: '<'
                    },
                    {
                        displayName: '<=',
                        name: '<='
                    },                    
                    {
                        displayName: '=',
                        name: '='
                    },                    
                    {
                        displayName: '>=',
                        name: '>='
                    },                    
                    {
                        displayName: '>',
                        name: '>'
                    },                    
                    {
                        displayName: '!=',
                        name: '!='
                    },                    
                    {
                        displayName: 'contains',
                        name: 'contains'
                    },                    
                    {
                        displayName: '!contains',
                        name: '!contains'
                    }            
                    ]
        });

        var margins = '5 5 5 5';
        this.down('#filterPanel').removeAll();
        this.down('#filterPanel').add([
            {
                xtype: 'text',
                text: 'Filter the grid =>',
                margin: margins,
                width:250,
                defaultAlign: 'bottom'
            },
            {
                name: 'fieldName',
                itemId: 'fieldName',
                xtype:'combobox',
                fieldLabel: 'Field:',
                store: fields_data,
                queryMode: 'local',
                displayField: 'displayName',
                valueField: 'name',
                width:250,
                labelWidth: 100,
                margin: margins,
                stateful:true,
                stateId: me.getContext().getScopedStateId('fieldName')
            },
            {
                name: 'operatorList',
                itemId: 'operatorList',
                xtype:'combobox',
                fieldLabel: 'Operator:',
                store: operator_data,
                queryMode: 'local',
                displayField: 'displayName',
                valueField: 'name',
                width:200,
                labelWidth: 100,
                margin: margins,
                stateful:true,
                stateId: me.getContext().getScopedStateId('operatorList')
            },
            {
                name: 'searchValue',
                itemId: 'searchValue',
                xtype:'textfield',
                fieldLabel: 'Value:',
                width:250,
                labelWidth: 100,
                margin: margins,
                stateful:true,
                stateId: me.getContext().getScopedStateId('searchValue'),
                listeners: {
                    change: me._filterGrid,
                    scope:me
                }
            },
            {
                name: 'filterButton',
                itemId: 'filterButton',
                xtype: 'button',
                text: 'Filter',
                listeners: {
                    click: me._filterGrid,
                    scope:me
                },
                margin: margins                
            },
            {
                name: 'clearFilterButton',
                itemId: 'clearFilterButton',
                xtype: 'button',
                text: 'Clear Filter',
                listeners: {
                    click: me._clearFilter,
                    scope:me
                },
                margin: margins                
            }
        ]);


        this.add(app.grid);
        //Ext.util.Observable.capture(app.grid, function(evname) {console.log("fired>>",evname, arguments);})
    },

    _filterGrid: function(){
            var field = this.down('#fieldName') && this.down('#fieldName').value;
            var operator = this.down('#operatorList') && this.down('#operatorList').value;
            var value = this.down('#searchValue') && this.down('#searchValue').value;

            console.log(field,operator,value);
            if(field && operator && value){
                var store = app.grid.getStore();
                    store.clearFilter();
                    store.filter([{property: field, operator: operator, value: value}]);                     
            }
    },

    _clearFilter: function(){
        var me = this;
        var store = app.grid.getStore();
            store.clearFilter();
            me.down('#fieldName').reset();
            me.down('#operatorList').reset();
            me.down('#searchValue').reset();    
    },

    getSubOperationValue: function(r){
        var value = '';
        if(Ext.getCmp('projectFilter').getValue() && r.get("TimeEntryProjectObject").get("c_KMDTimeregistrationIntegration")=="Yes with suboperation substitution")   {
            value = r.get("UserObject").get("c_DefaultSAPSubOperation");
        } else {
            value = app.getFieldValue(r, 'c_SAPSubOperation');
        }
        return value;
    },

    // creates a url link for the column based on the formatted id in the column
    renderLink: function(textValue, record) {

        var fid = _.first(textValue.split(":"));

        var obj = _.find(record.get("Hierarchy"), function(hObj) {
            return fid === hObj.get("FormattedID");
        });
        if (!_.isUndefined(obj) && !_.isNull(obj)) {
            return '<a href=' + Rally.nav.Manager.getDetailUrl(obj) + ' target="_blank">' + textValue + '</a>';
        }
        return textValue;
    },

    readRelatedValues: function(values, callback) {
        // time entry items
        app.readTimeEntryItems(values).then({

            success: function(items) {
                app.setValues(values, items, "TimeEntryItemObject");

                // project
                app.readProjects(items).then({
                    success: function(projects) {
                        app.setValues(values, projects, "TimeEntryProjectObject");
                    }
                });

                // users
                app.readUsers(items).then({
                    success: function(users) {
                        app.setValues(values, users, "UserObject");
                        // read work item hierarchies
                        app.readHierarchies(items).then({
                            success: function(hierarchies) {

                                app.setValues(values, hierarchies, "Hierarchy");
                                callback();
                            }
                        });
                    }
                });
            }
        });
    },

    readHierarchies: function(items) {

        var deferred = Ext.create('Deft.Deferred');
        // read task or workproduct, depending on timeentryitem type
        var p = _.map(items, function(item) {
            var obj = (!_.isUndefined(item.get("Task")) &&
                    !_.isNull(item.get("Task"))) ?
                item.get("Task") : item.get("WorkProduct");
            // return app.readObject(obj._type,obj);
            return app.readObject(obj);
        });

        Deft.Promise.all(p).then({
            success: function(values) {
                // get parent hierarchy
                var p2 = _.map(values, function(value) {
                    return app.recurseUpObject(value);
                });
                Deft.Promise.all(p2).then({
                    success: function(hierarchies) {
                        deferred.resolve(hierarchies);
                    }
                });
            }
        });
        return deferred.promise;
    },

    setValues: function(items, values, attrName) {
        _.each(items, function(item, x) {
            item.set(attrName, values[x]);
        });
    },

    // TimesheetEntryItems -> Stories -> Features -> Epics

    // readObject : function(model,ref) {
    readObject: function(object) {

        var deferred = Ext.create('Deft.Deferred');

        if (_.isNull(object)) {
            deferred.resolve(null);
        } else {
            var obj = _.find(app.cache, function(cacheObj) {
                if (cacheObj.object._ref === object._ref) {
                    return cacheObj.promise.promise;
                }
            });

            if (!_.isUndefined(obj) && !_.isNull(obj)) {
                return obj.promise.promise;
            } else {
                Rally.data.ModelFactory.getModel({
                    type: object._type,
                    success: function(model) {
                        model.load(object, {
                            fetch: true,
                            callback: function(result, operation) {

                                deferred.resolve(result);
                            }
                        });
                    }
                });
                app.cache.push({
                    object: object,
                    promise: deferred
                });
                return deferred.promise;
            }
        }
    },

    // given an object, it will read all parent items based on type and return in a list
    recurseUpObject: function(obj) {

        var deferred = Ext.create('Deft.Deferred');
        var list = []; //var stack = 1;

        var parentItem = function(obj, callback) {
            var type = _.first(obj.get("_type").split("/")).toLowerCase();

            switch (type) {
                case 'task':
                    parentAttr = 'WorkProduct';
                    break;
                case 'defect':
                    parentAttr = 'Requirement';
                    break;
                case 'hierarchicalrequirement':
                    parentAttr = (!_.isNull(obj.get("Parent")) ? "Parent" : "PortfolioItem");
                    break;
                case 'portfolioitem':
                    parentAttr = 'Parent';
                    break;
            }

            var parentRef = obj.get(parentAttr);
            if (!_.isUndefined(parentRef) && !_.isNull(parentRef)) {
                // app.readObject(parentRef._type,parentRef).then({
                app.readObject(parentRef).then({
                    success: function(r) {
                        callback(r);
                    }
                });
            } else {
                callback(null);
            }
        };

        var walk = function(root) {
            list.push(root);
            parentItem(root, function(result) {
                if (result !== null) {
                    walk(result);
                } else {
                    deferred.resolve(list);
                }
            });
        };

        if (_.isUndefined(obj) || _.isNull(obj)) {
            deferred.resolve(null);
        } else {
            walk(obj);
            return deferred.promise;
        }
    },

    readUsers: function(items) {
        var promises = _.map(items, function(item) {
            var deferred = Ext.create('Deft.Deferred');
            var userRef = item.get("User");
            if (_.isUndefined(userRef) || _.isNull(userRef)) {
                deferred.resolve(null);
            } else {
                // app.readObject('User',userRef).then({
                app.readObject(userRef).then({
                    success: function(obj) {
                        deferred.resolve(obj);
                    }
                });
            }
            return deferred.promise;
        });
        return Deft.Promise.all(promises);
    },

    readProjects: function(items) {
        var promises = _.map(items, function(item) {
            var deferred = Ext.create('Deft.Deferred');
            var projectRef = item.get("Project");
            if (_.isUndefined(projectRef) || _.isNull(projectRef)) {
                deferred.resolve(null);
            } else {
                // app.readObject('User',userRef).then({
                app.readObject(projectRef).then({
                    success: function(obj) {
                        deferred.resolve(obj);
                    }
                });
            }
            return deferred.promise;
        });
        return Deft.Promise.all(promises);
    },

    readTimeEntryItems: function(values) {
        var promises = _.map(values, function(v) {
            var deferred = Ext.create('Deft.Deferred');
            var ref = v.get("TimeEntryItem");

            //app.readObject('TimeEntryItem',ref).then({
            app.readObject(ref).then({
                success: function(obj) {
                    deferred.resolve(obj);
                }
            });
            return deferred.promise;
        });
        return Deft.Promise.all(promises);
    },

    _getDateFilter: function() {
        var startDateCmp = Ext.getCmp('startDate').getValue();
        var endDateCmp = Ext.getCmp('endDate').getValue();
        //Include the selected end date.
        endDateCmp.setHours(23,59,59);

        var start = Rally.util.DateTime.toIsoString(startDateCmp, false);
        var end = Rally.util.DateTime.toIsoString(endDateCmp, false);

        return [{
            property: 'DateVal',
            operator: '>=',
            value: start
        }, {
            property: 'DateVal',
            operator: '<=',
            value: end
        }];
    },

    _onSelect: function() {
        var grid = Ext.getCmp('tsGrid'),
            store = grid.getStore();

        store.clearFilter(true);
        store.filter(app._getDateFilter());
    },

    _onSelectDate: function(a, b, c) {
        console.log(a, b, c);
    },

    showMask: function(msg) {
        if (this.getEl()) {
            this.getEl().unmask();
            this.getEl().mask(msg);
        }
    },
    hideMask: function() {
        this.getEl().unmask();
    },
    _loadAStoreWithAPromise: function(model_name, model_fields, filters, ctx, order) {

        var deferred = Ext.create('Deft.Deferred');
        var me = this;

        var config = {
            model: model_name,
            fetch: model_fields,
            filters: filters,
            limit: 'Infinity'
        };
        if (!_.isUndefined(ctx) && !_.isNull(ctx)) {
            config.context = ctx;
        }
        if (!_.isUndefined(order) && !_.isNull(order)) {
            config.order = order;
        }

        Ext.create('Rally.data.wsapi.Store', config).load({
            callback: function(records, operation, successful) {
                if (successful) {
                    deferred.resolve(records);
                } else {
                    deferred.reject('Problem loading: ' + operation.error.errors.join('. '));
                }
            }
        });
        return deferred.promise;
    },
    getOptions: function() {
        return [
            {
                text: 'About...',
                handler: this._launchInfo,
                scope: this
            }
        ];
    },

    _launchInfo: function() {
        if ( this.about_dialog ) { this.about_dialog.destroy(); }
        this.about_dialog = Ext.create('Rally.technicalservices.InfoLink',{});
    },

    isExternal: function(){
        return typeof(this.getAppId()) == 'undefined';
    }

});
            
               Rally.launchApp('PTApp', {
                   name: 'Portfolio Timesheet App'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}
    </style>

</head>
<body></body>
</html>