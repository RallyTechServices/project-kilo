<!DOCTYPE html>
<html>
<head>
    <title>Portfolio Timesheet App</title>
    <!--  (c) 2016 CA Technologies.  All Rights Reserved. -->
    <!--  Build Date: Thu Sep 01 2016 13:16:36 GMT-0400 (EDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Thu Sep 01 2016 13:16:36 GMT-0400 (EDT)";
        var STORY    = "US8846";
        var BUILDER  = "arajaraman";
        var CHECKSUM = 105540324148;
    </script>
    
    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",
    
    defaults: { padding: 5, margin: 5 },

    closable: true,
     
    draggable: true,

    autoShow: true,
   
    width: 350,
    
    informationalConfig: null,
    
    items: [{xtype:'container', itemId:'information' }],
    
    initComponent: function() {
        var id = Ext.id(this);
        this.title =  "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },
    
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/var BUILDER  = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
       
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
   
        return chk;
    },
    
    _checkChecksum: function(container) {
        var deferred = Ext.create('Deft.Deferred');
        var me = this;
        
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    var stored_checksum = me._generateChecksum(text);
                    if ( CHECKSUM !== stored_checksum ) {
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });
        
        return deferred.promise;
    },
    
    _addToContainer: function(container){
        var config = Ext.apply({
            xtype:'container',
            height: 200,
            overflowY: true
        }, this.informationalConfig);
        
        container.add(config);
    },
    
    afterRender: function() {
        var app = Rally.getApp();
        
        if ( !Ext.isEmpty( this.informationalConfig ) ) {
            var container = this.down('#information');
            this._addToContainer(container);
            
        }
        
        if (! app.isExternal() ) {
            this._checkChecksum(app).then({
                scope: this,
                success: function(result){
                    if ( !result ) {
                        this.addDocked({
                            xtype:'container',
                            cls: 'build-info',
                            dock: 'bottom',
                            padding: 2,
                            html:'<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                },
                failure: function(msg){
                    console.log("oops:",msg);
                }
            });
        } else {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html:'... Running externally'
            });
        }
        this.callParent(arguments);
    },
    
    beforeRender: function() {
        var me = this;
        this.callParent(arguments);

        if (this.informationHtml) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: this.informationHtml,
                doc: 'top'
            });
        }
        
        this.addDocked({
            xtype:'container',
            cls: 'build-info',
            padding: 2,
            dock:'bottom',
            html:"This app was created by the CA AC Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            var build_html = Ext.String.format("Built on: {0} <br/>Built by: {1}",
                APP_BUILD_DATE,
                BUILDER);
                
            if ( STORY ) {
                build_html = build_html + "<br/>Source story: " + STORY;
            }
                
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html: build_html
            });
        }
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define("GridExporter", {
    //dateFormat : 'Y-m-d g:i',
    dateFormat: 'Y-m-d',

    inheritableStatics: {
        XmlFileHeader: '<?xml version="1.0"?>',
        XmlFileExtension: '.xml.txt'
    },

    _downloadFiles: function(files) {
        if (files.length) {
            var data = files.pop();
            var format = files.pop();
            var file = files.pop();

            var href = "<a href='" + format + "," + encodeURIComponent(data) + "' download='" + file + "'></a>";

            var ml = Ext.DomHelper.insertAfter(window.document.getElementById('tsGrid'), href);
            ml.click();
            //            ml.remove(); //Leaves them behind without this, but there is a timing issue: from click to remove.
            this._downloadFiles(files);
        }
    },

    exportCSV: function(grid) {
        var data = this._getCSV(grid, false);
        // fix: ' character was causing termination of csv file
        data = data.replace(/\'/g, "");
        this._downloadFiles(
            [
                'export.csv', 'data:text/csv;charset=utf8', data
            ]
        );

    },

    _XMLIndent: function(index, tag, leaf, data) {
        if (leaf === true)
            data = _.escape(data);

        var text = '\n';
        for (var i = 0; i < index; i++) text += '\t';
        text += '<' + tag + '>';
        text += data;
        if (!leaf) {
            text += '\n';
            for (i = 0; i < index; i++) text += '\t';
        }
        text += '</' + tag + '>';
        return text;

    },

    _addSAPTrailerFile: function(data) {

        var file = 'E1BPCATS8';
        var format = 'data:text/text;charset=utf8';
        var text = this.self.XmlFileHeader;

        text += "\n<" + file + ">";
        _.each(data, function(record) {
            if (record.get('c_SAPNetwork') && record.get('c_SAPOperation') && record.get('c_KMDEmployeeID')) {
                text += this._XMLIndent(1, 'Datarow', false,
                    this._XMLIndent(2, 'GUID', true, record.get('ObjectID')) +
                    this._XMLIndent(2, 'ROW', true, '1') +
                    this._XMLIndent(2, 'FORMAT_COL', true, '*') +
                    // this._XMLIndent(2, 'TEXT_LINE', true, '')
                    this._XMLIndent(2, 'TEXT_LINE', true, record.get('TaskDisplayString') || record.get('WorkProductDisplayString') || '')
                );
            }
        }, this);

        text += "</" + file + ">\n";
        file += this.self.XmlFileExtension;
        return [file, format, text];
    },

    _addSAPHeaderFile: function(data) {

        var file = 'E1CATS_INSERT';
        var format = 'data:text/text;charset=utf8';
        var text = this.self.XmlFileHeader;

        text += "\n<" + file + ">";
        _.each(data, function(record) {
            if (record.get('c_SAPNetwork') && record.get('c_SAPOperation') && record.get('c_KMDEmployeeID')) {
                text += this._XMLIndent(1, 'Datarow', false,
                    this._XMLIndent(2, 'GUID', true, record.get('ObjectID')) +
                    this._XMLIndent(2, 'PROFILE', true, record.get('c_KMDEmployeeID') || '') +
                    this._XMLIndent(2, 'TEXT_FORMAT_IMP', true, 'ITF')
                );
            }
        }, this);

        text += "</" + file + ">\n";
        file += this.self.XmlFileExtension;
        return [file, format, text];
    },

    _addSAPDataFile: function(data,xmlConfig) {
        console.log('xmlConfig>>>>>',xmlConfig);
        var file = 'E1BPCATS1';
        var format = 'data:text/text;charset=utf8';
        var text = this.self.XmlFileHeader;

        text += "\n<" + file + ">";
        _.each(data, function(record) {
            if (record.get('c_SAPNetwork') && record.get('c_SAPOperation') && record.get('c_KMDEmployeeID')) {
                text += this._XMLIndent(1, 'Datarow', false,
                    this._XMLIndent(2, 'GUID', true, record.get('ObjectID') || '') +
                    this._XMLIndent(2, 'WORKDATE', true, record.get('Date')) /*Ext.Date.format(new Date(record.get('Date')), 'Ymd')) */ +
                    this._XMLIndent(2, 'EMPLOYEENUMBER', true, record.get('c_KMDEmployeeID') || '') +
                    this._XMLIndent(2, 'ACTTYPE', true, '1') +
                    this._XMLIndent(2, 'NETWORK', true, record.get('c_SAPNetwork') || '') +
                    this._XMLIndent(2, 'ACTIVITY', true, record.get('c_SAPOperation') || '') +
                    (record.get('c_SAPSubOperation') ? this._XMLIndent(2, 'SUB_ACTIVITY', true, record.get('c_SAPSubOperation')) : '') +
                    this._XMLIndent(2, 'CATSHOURS', true, record.get('Hours')) +
                    this._XMLIndent(2, 'UNIT', true, 'H') +
                    this._XMLIndent(2, 'SHORTTEXT', true, record.get('TaskDisplayString') || record.get('WorkProductDisplayString') || '') +
                    this._XMLIndent(2, 'LONGTEXT', true, 'X') +
                    (xmlConfig.extApplication ? this._XMLIndent(2, 'EXTAPPLICATION', true, xmlConfig.extApplicationValue ) : '')
                );
            }
        }, this);
        text += "</" + file + ">\n";
        file += this.self.XmlFileExtension;
        return [file, format, text];

    },

    _addSAPErrorsFile: function(grid) {
        var file = 'SAPErrors.csv';
        var format = 'data:text/csv;charset=utf8';

        var text = this._getCSV(grid, true);
        if (text) return [file, format, text];
        else return null;
    },

    exportSAPXML: function(grid,xmlConfig) {

        var filesToSave = [];

        if (grid && grid.store && grid.store.data) {
            var data = grid.store.data.items;
            var errors = this._addSAPErrorsFile(grid);

            //            if (errors) {
            this._downloadFiles(errors);
            //            }
            //            else {
            this._downloadFiles(filesToSave.concat(
                this._addSAPHeaderFile(data),
                this._addSAPDataFile(data,xmlConfig),
                this._addSAPTrailerFile(data)
            ));
            //            }
        }

    },

    _escapeForCSV: function(string) {
        string = "" + string;
        if (string.match(/,/)) {
            if (!string.match(/"/)) {
                string = '"' + string + '"';
            } else {
                string = string.replace(/,/g, ''); // comma's and quotes-- sorry, just lose the commas
            }
        }
        return string;
    },

    _getFieldText: function(fieldData, record, col, index) {
        var text;

        if (fieldData === null || fieldData === undefined) {
            text = '';

        } else if (fieldData._refObjectName && !fieldData.getMonth) {
            text = fieldData._refObjectName;

        } else if (fieldData instanceof Date) {
            text = Ext.Date.format(fieldData, this.dateFormat);

        }
        /*else if (!fieldData.match) { // not a string or object we recognize...bank it out
                   text = '';
               } */
        else {
            text = fieldData;
        }

        return text;
    },

    _getFieldTextAndEscape: function(fieldData, record, col, index) {
        var string = this._getFieldText(fieldData, record, col, index);

        return this._escapeForCSV(string);
    },

    // have to add the colIdx to the count of locked columns
    fixedColumnCount: function(columns) {
        var cols = _.filter(columns, function(c) {
            return c !== undefined && c !== null && c.locked === true;
        });
        return cols.length;
    },

    _getCSV: function(grid, onlyErrors) {
        var cols = grid.columns;
        var store = grid.store;
        var hdrData = '';
        var rowData = '';
        var valid = true;

        var that = this;
        Ext.Array.each(cols, function(col, index) {
            // Ext.Array.each(sortedCols, function(col, index) { 
            // console.log(col);
            if (col.hidden !== true) {
                // fix the issue with the "SYLK" warning in excel by prepending "Item" to the ID column
                var colLabel = col.dataIndex;
                //                var colLabel = (index === 0 ? "Item " : "") + col.dataIndex;
                colLabel = colLabel.replace(/<br\/?>/, '');
                hdrData += that._getFieldTextAndEscape(colLabel) + ',';
            }
        });
        hdrData += "\n";

        _.each(store.data.items, function(record, i) {
            valid = record.get('c_SAPNetwork') && record.get('c_SAPOperation') && record.get('c_KMDEmployeeID');
            if ((!onlyErrors) || (!valid)) {
                Ext.Array.each(cols, function(col, index) {

                    if (col.hidden !== true) {
                        var fieldName = col.dataIndex;
                        var text = record.get(fieldName);
                        rowData += that._getFieldTextAndEscape(text, record, col, index) + ',';
                    }
                });
                rowData += "\n";
            }
        });

        return hdrData + rowData;
    }
});
/*
 Copyright (c) 2013 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

(function(obj) {
    "use strict";

    var ERR_BAD_FORMAT = "File format is not recognized.";
    var ERR_CRC = "CRC failed.";
    var ERR_ENCRYPTED = "File contains encrypted entry.";
    var ERR_ZIP64 = "File is using Zip64 (4gb+ file size).";
    var ERR_READ = "Error while reading zip file.";
    var ERR_WRITE = "Error while writing zip file.";
    var ERR_WRITE_DATA = "Error while writing file data.";
    var ERR_READ_DATA = "Error while reading file data.";
    var ERR_DUPLICATED_NAME = "File already exists.";
    var CHUNK_SIZE = 512 * 1024;

    var TEXT_PLAIN = "text/plain";

    var appendABViewSupported;
    try {
        appendABViewSupported = new Blob([new DataView(new ArrayBuffer(0))]).size === 0;
    } catch (e) {}

    function Crc32() {
        this.crc = -1;
    }
    Crc32.prototype.append = function append(data) {
        var crc = this.crc | 0,
            table = this.table;
        for (var offset = 0, len = data.length | 0; offset < len; offset++)
            crc = (crc >>> 8) ^ table[(crc ^ data[offset]) & 0xFF];
        this.crc = crc;
    };
    Crc32.prototype.get = function get() {
        return~ this.crc;
    };
    Crc32.prototype.table = (function() {
        var i, j, t, table = []; // Uint32Array is actually slower than []
        for (i = 0; i < 256; i++) {
            t = i;
            for (j = 0; j < 8; j++)
                if (t & 1)
                    t = (t >>> 1) ^ 0xEDB88320;
                else
                    t = t >>> 1;
            table[i] = t;
        }
        return table;
    })();

    // "no-op" codec

    function NOOP() {}
    NOOP.prototype.append = function append(bytes, onprogress) {
        return bytes;
    };
    NOOP.prototype.flush = function flush() {};

    function blobSlice(blob, index, length) {
        if (index < 0 || length < 0 || index + length > blob.size)
            throw new RangeError('offset:' + index + ', length:' + length + ', size:' + blob.size);
        if (blob.slice)
            return blob.slice(index, index + length);
        else if (blob.webkitSlice)
            return blob.webkitSlice(index, index + length);
        else if (blob.mozSlice)
            return blob.mozSlice(index, index + length);
        else if (blob.msSlice)
            return blob.msSlice(index, index + length);
    }

    function getDataHelper(byteLength, bytes) {
        var dataBuffer, dataArray;
        dataBuffer = new ArrayBuffer(byteLength);
        dataArray = new Uint8Array(dataBuffer);
        if (bytes)
            dataArray.set(bytes, 0);
        return {
            buffer: dataBuffer,
            array: dataArray,
            view: new DataView(dataBuffer)
        };
    }

    // Readers

    function Reader() {}

    function TextReader(text) {
        var that = this,
            blobReader;

        function init(callback, onerror) {
            var blob = new Blob([text], {
                type: TEXT_PLAIN
            });
            blobReader = new BlobReader(blob);
            blobReader.init(function() {
                that.size = blobReader.size;
                callback();
            }, onerror);
        }

        function readUint8Array(index, length, callback, onerror) {
            blobReader.readUint8Array(index, length, callback, onerror);
        }

        that.size = 0;
        that.init = init;
        that.readUint8Array = readUint8Array;
    }
    TextReader.prototype = new Reader();
    TextReader.prototype.constructor = TextReader;

    function Data64URIReader(dataURI) {
        var that = this,
            dataStart;

        function init(callback) {
            var dataEnd = dataURI.length;
            while (dataURI.charAt(dataEnd - 1) == "=")
                dataEnd--;
            dataStart = dataURI.indexOf(",") + 1;
            that.size = Math.floor((dataEnd - dataStart) * 0.75);
            callback();
        }

        function readUint8Array(index, length, callback) {
            var i, data = getDataHelper(length);
            var start = Math.floor(index / 3) * 4;
            var end = Math.ceil((index + length) / 3) * 4;
            var bytes = obj.atob(dataURI.substring(start + dataStart, end + dataStart));
            var delta = index - Math.floor(start / 4) * 3;
            for (i = delta; i < delta + length; i++)
                data.array[i - delta] = bytes.charCodeAt(i);
            callback(data.array);
        }

        that.size = 0;
        that.init = init;
        that.readUint8Array = readUint8Array;
    }
    Data64URIReader.prototype = new Reader();
    Data64URIReader.prototype.constructor = Data64URIReader;

    function BlobReader(blob) {
        var that = this;

        function init(callback) {
            that.size = blob.size;
            callback();
        }

        function readUint8Array(index, length, callback, onerror) {
            var reader = new FileReader();
            reader.onload = function(e) {
                callback(new Uint8Array(e.target.result));
            };
            reader.onerror = onerror;
            try {
                reader.readAsArrayBuffer(blobSlice(blob, index, length));
            } catch (e) {
                onerror(e);
            }
        }

        that.size = 0;
        that.init = init;
        that.readUint8Array = readUint8Array;
    }
    BlobReader.prototype = new Reader();
    BlobReader.prototype.constructor = BlobReader;

    // Writers

    function Writer() {}
    Writer.prototype.getData = function(callback) {
        callback(this.data);
    };

    function TextWriter(encoding) {
        var that = this,
            blob;

        function init(callback) {
            blob = new Blob([], {
                type: TEXT_PLAIN
            });
            callback();
        }

        function writeUint8Array(array, callback) {
            blob = new Blob([blob, appendABViewSupported ? array : array.buffer], {
                type: TEXT_PLAIN
            });
            callback();
        }

        function getData(callback, onerror) {
            var reader = new FileReader();
            reader.onload = function(e) {
                callback(e.target.result);
            };
            reader.onerror = onerror;
            reader.readAsText(blob, encoding);
        }

        that.init = init;
        that.writeUint8Array = writeUint8Array;
        that.getData = getData;
    }
    TextWriter.prototype = new Writer();
    TextWriter.prototype.constructor = TextWriter;

    function Data64URIWriter(contentType) {
        var that = this,
            data = "",
            pending = "";

        function init(callback) {
            data += "data:" + (contentType || "") + ";base64,";
            callback();
        }

        function writeUint8Array(array, callback) {
            var i, delta = pending.length,
                dataString = pending;
            pending = "";
            for (i = 0; i < (Math.floor((delta + array.length) / 3) * 3) - delta; i++)
                dataString += String.fromCharCode(array[i]);
            for (; i < array.length; i++)
                pending += String.fromCharCode(array[i]);
            if (dataString.length > 2)
                data += obj.btoa(dataString);
            else
                pending = dataString;
            callback();
        }

        function getData(callback) {
            callback(data + obj.btoa(pending));
        }

        that.init = init;
        that.writeUint8Array = writeUint8Array;
        that.getData = getData;
    }
    Data64URIWriter.prototype = new Writer();
    Data64URIWriter.prototype.constructor = Data64URIWriter;

    function BlobWriter(contentType) {
        var blob, that = this;

        function init(callback) {
            blob = new Blob([], {
                type: contentType
            });
            callback();
        }

        function writeUint8Array(array, callback) {
            blob = new Blob([blob, appendABViewSupported ? array : array.buffer], {
                type: contentType
            });
            callback();
        }

        function getData(callback) {
            callback(blob);
        }

        that.init = init;
        that.writeUint8Array = writeUint8Array;
        that.getData = getData;
    }
    BlobWriter.prototype = new Writer();
    BlobWriter.prototype.constructor = BlobWriter;

    /** 
     * inflate/deflate core functions
     * @param worker {Worker} web worker for the task.
     * @param initialMessage {Object} initial message to be sent to the worker. should contain
     *   sn(serial number for distinguishing multiple tasks sent to the worker), and codecClass.
     *   This function may add more properties before sending.
     */

    function launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror) {
        var chunkIndex = 0,
            index, outputSize, sn = initialMessage.sn,
            crc;

        function onflush() {
            worker.removeEventListener('message', onmessage, false);
            onend(outputSize, crc);
        }

        function onmessage(event) {
            var message = event.data,
                data = message.data,
                err = message.error;
            if (err) {
                err.toString = function() {
                    return 'Error: ' + this.message;
                };
                onreaderror(err);
                return;
            }
            if (message.sn !== sn)
                return;
            if (typeof message.codecTime === 'number')
                worker.codecTime += message.codecTime; // should be before onflush()
            if (typeof message.crcTime === 'number')
                worker.crcTime += message.crcTime;

            switch (message.type) {
                case 'append':
                    if (data) {
                        outputSize += data.length;
                        writer.writeUint8Array(data, function() {
                            step();
                        }, onwriteerror);
                    } else
                        step();
                    break;
                case 'flush':
                    crc = message.crc;
                    if (data) {
                        outputSize += data.length;
                        writer.writeUint8Array(data, function() {
                            onflush();
                        }, onwriteerror);
                    } else
                        onflush();
                    break;
                case 'progress':
                    if (onprogress)
                        onprogress(index + message.loaded, size);
                    break;
                case 'importScripts': //no need to handle here
                case 'newTask':
                case 'echo':
                    break;
                default:
                    console.warn('zip.js:launchWorkerProcess: unknown message: ', message);
            }
        }

        function step() {
            index = chunkIndex * CHUNK_SIZE;
            if (index < size) {
                reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(array) {
                    if (onprogress)
                        onprogress(index, size);
                    var msg = index === 0 ? initialMessage : {
                        sn: sn
                    };
                    msg.type = 'append';
                    msg.data = array;
                    worker.postMessage(msg, [array.buffer]);
                    chunkIndex++;
                }, onreaderror);
            } else {
                worker.postMessage({
                    sn: sn,
                    type: 'flush'
                });
            }
        }

        outputSize = 0;
        worker.addEventListener('message', onmessage, false);
        step();
    }

    function launchProcess(process, reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror) {
        var chunkIndex = 0,
            index, outputSize = 0,
            crcInput = crcType === 'input',
            crcOutput = crcType === 'output',
            crc = new Crc32();

        function step() {
            var outputData;
            index = chunkIndex * CHUNK_SIZE;
            if (index < size)
                reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(inputData) {
                    var outputData;
                    try {
                        outputData = process.append(inputData, function(loaded) {
                            if (onprogress)
                                onprogress(index + loaded, size);
                        });
                    } catch (e) {
                        onreaderror(e);
                        return;
                    }
                    if (outputData) {
                        outputSize += outputData.length;
                        writer.writeUint8Array(outputData, function() {
                            chunkIndex++;
                            setTimeout(step, 1);
                        }, onwriteerror);
                        if (crcOutput)
                            crc.append(outputData);
                    } else {
                        chunkIndex++;
                        setTimeout(step, 1);
                    }
                    if (crcInput)
                        crc.append(inputData);
                    if (onprogress)
                        onprogress(index, size);
                }, onreaderror);
            else {
                try {
                    outputData = process.flush();
                } catch (e) {
                    onreaderror(e);
                    return;
                }
                if (outputData) {
                    if (crcOutput)
                        crc.append(outputData);
                    outputSize += outputData.length;
                    writer.writeUint8Array(outputData, function() {
                        onend(outputSize, crc.get());
                    }, onwriteerror);
                } else
                    onend(outputSize, crc.get());
            }
        }

        step();
    }

    function inflate(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
        var crcType = computeCrc32 ? 'output' : 'none';
        if (obj.zip.useWebWorkers) {
            var initialMessage = {
                sn: sn,
                codecClass: 'Inflater',
                crcType: crcType,
            };
            launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);
        } else
            launchProcess(new obj.zip.Inflater(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror);
    }

    function deflate(worker, sn, reader, writer, level, onend, onprogress, onreaderror, onwriteerror) {
        var crcType = 'input';
        if (obj.zip.useWebWorkers) {
            var initialMessage = {
                sn: sn,
                options: {
                    level: level
                },
                codecClass: 'Deflater',
                crcType: crcType,
            };
            launchWorkerProcess(worker, initialMessage, reader, writer, 0, reader.size, onprogress, onend, onreaderror, onwriteerror);
        } else
            launchProcess(new obj.zip.Deflater(), reader, writer, 0, reader.size, crcType, onprogress, onend, onreaderror, onwriteerror);
    }

    function copy(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
        var crcType = 'input';
        if (obj.zip.useWebWorkers && computeCrc32) {
            var initialMessage = {
                sn: sn,
                codecClass: 'NOOP',
                crcType: crcType,
            };
            launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);
        } else
            launchProcess(new NOOP(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror);
    }

    // ZipReader

    function decodeASCII(str) {
        var i, out = "",
            charCode, extendedASCII = ['\u00C7', '\u00FC', '\u00E9', '\u00E2', '\u00E4', '\u00E0', '\u00E5', '\u00E7', '\u00EA', '\u00EB',
                '\u00E8', '\u00EF', '\u00EE', '\u00EC', '\u00C4', '\u00C5', '\u00C9', '\u00E6', '\u00C6', '\u00F4', '\u00F6', '\u00F2', '\u00FB', '\u00F9',
                '\u00FF', '\u00D6', '\u00DC', '\u00F8', '\u00A3', '\u00D8', '\u00D7', '\u0192', '\u00E1', '\u00ED', '\u00F3', '\u00FA', '\u00F1', '\u00D1',
                '\u00AA', '\u00BA', '\u00BF', '\u00AE', '\u00AC', '\u00BD', '\u00BC', '\u00A1', '\u00AB', '\u00BB', '_', '_', '_', '\u00A6', '\u00A6',
                '\u00C1', '\u00C2', '\u00C0', '\u00A9', '\u00A6', '\u00A6', '+', '+', '\u00A2', '\u00A5', '+', '+', '-', '-', '+', '-', '+', '\u00E3',
                '\u00C3', '+', '+', '-', '-', '\u00A6', '-', '+', '\u00A4', '\u00F0', '\u00D0', '\u00CA', '\u00CB', '\u00C8', 'i', '\u00CD', '\u00CE',
                '\u00CF', '+', '+', '_', '_', '\u00A6', '\u00CC', '_', '\u00D3', '\u00DF', '\u00D4', '\u00D2', '\u00F5', '\u00D5', '\u00B5', '\u00FE',
                '\u00DE', '\u00DA', '\u00DB', '\u00D9', '\u00FD', '\u00DD', '\u00AF', '\u00B4', '\u00AD', '\u00B1', '_', '\u00BE', '\u00B6', '\u00A7',
                '\u00F7', '\u00B8', '\u00B0', '\u00A8', '\u00B7', '\u00B9', '\u00B3', '\u00B2', '_', ' '
            ];
        for (i = 0; i < str.length; i++) {
            charCode = str.charCodeAt(i) & 0xFF;
            if (charCode > 127)
                out += extendedASCII[charCode - 128];
            else
                out += String.fromCharCode(charCode);
        }
        return out;
    }

    function decodeUTF8(string) {
        return decodeURIComponent(escape(string));
    }

    function getString(bytes) {
        var i, str = "";
        for (i = 0; i < bytes.length; i++)
            str += String.fromCharCode(bytes[i]);
        return str;
    }

    function getDate(timeRaw) {
        var date = (timeRaw & 0xffff0000) >> 16,
            time = timeRaw & 0x0000ffff;
        try {
            return new Date(1980 + ((date & 0xFE00) >> 9), ((date & 0x01E0) >> 5) - 1, date & 0x001F, (time & 0xF800) >> 11, (time & 0x07E0) >> 5, (time & 0x001F) * 2, 0);
        } catch (e) {}
    }

    function readCommonHeader(entry, data, index, centralDirectory, onerror) {
        entry.version = data.view.getUint16(index, true);
        entry.bitFlag = data.view.getUint16(index + 2, true);
        entry.compressionMethod = data.view.getUint16(index + 4, true);
        entry.lastModDateRaw = data.view.getUint32(index + 6, true);
        entry.lastModDate = getDate(entry.lastModDateRaw);
        if ((entry.bitFlag & 0x01) === 0x01) {
            onerror(ERR_ENCRYPTED);
            return;
        }
        if (centralDirectory || (entry.bitFlag & 0x0008) != 0x0008) {
            entry.crc32 = data.view.getUint32(index + 10, true);
            entry.compressedSize = data.view.getUint32(index + 14, true);
            entry.uncompressedSize = data.view.getUint32(index + 18, true);
        }
        if (entry.compressedSize === 0xFFFFFFFF || entry.uncompressedSize === 0xFFFFFFFF) {
            onerror(ERR_ZIP64);
            return;
        }
        entry.filenameLength = data.view.getUint16(index + 22, true);
        entry.extraFieldLength = data.view.getUint16(index + 24, true);
    }

    function createZipReader(reader, callback, onerror) {
        var inflateSN = 0;

        function Entry() {}

        Entry.prototype.getData = function(writer, onend, onprogress, checkCrc32) {
            var that = this;

            function testCrc32(crc32) {
                var dataCrc32 = getDataHelper(4);
                dataCrc32.view.setUint32(0, crc32);
                return that.crc32 == dataCrc32.view.getUint32(0);
            }

            function getWriterData(uncompressedSize, crc32) {
                if (checkCrc32 && !testCrc32(crc32))
                    onerror(ERR_CRC);
                else
                    writer.getData(function(data) {
                        onend(data);
                    });
            }

            function onreaderror(err) {
                onerror(err || ERR_READ_DATA);
            }

            function onwriteerror(err) {
                onerror(err || ERR_WRITE_DATA);
            }

            reader.readUint8Array(that.offset, 30, function(bytes) {
                var data = getDataHelper(bytes.length, bytes),
                    dataOffset;
                if (data.view.getUint32(0) != 0x504b0304) {
                    onerror(ERR_BAD_FORMAT);
                    return;
                }
                readCommonHeader(that, data, 4, false, onerror);
                dataOffset = that.offset + 30 + that.filenameLength + that.extraFieldLength;
                writer.init(function() {
                    if (that.compressionMethod === 0)
                        copy(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);
                    else
                        inflate(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);
                }, onwriteerror);
            }, onreaderror);
        };

        function seekEOCDR(eocdrCallback) {
            // "End of central directory record" is the last part of a zip archive, and is at least 22 bytes long.
            // Zip file comment is the last part of EOCDR and has max length of 64KB,
            // so we only have to search the last 64K + 22 bytes of a archive for EOCDR signature (0x06054b50).
            var EOCDR_MIN = 22;
            if (reader.size < EOCDR_MIN) {
                onerror(ERR_BAD_FORMAT);
                return;
            }
            var ZIP_COMMENT_MAX = 256 * 256,
                EOCDR_MAX = EOCDR_MIN + ZIP_COMMENT_MAX;

            // In most cases, the EOCDR is EOCDR_MIN bytes long
            doSeek(EOCDR_MIN, function() {
                // If not found, try within EOCDR_MAX bytes
                doSeek(Math.min(EOCDR_MAX, reader.size), function() {
                    onerror(ERR_BAD_FORMAT);
                });
            });

            // seek last length bytes of file for EOCDR

            function doSeek(length, eocdrNotFoundCallback) {
                reader.readUint8Array(reader.size - length, length, function(bytes) {
                    for (var i = bytes.length - EOCDR_MIN; i >= 0; i--) {
                        if (bytes[i] === 0x50 && bytes[i + 1] === 0x4b && bytes[i + 2] === 0x05 && bytes[i + 3] === 0x06) {
                            eocdrCallback(new DataView(bytes.buffer, i, EOCDR_MIN));
                            return;
                        }
                    }
                    eocdrNotFoundCallback();
                }, function() {
                    onerror(ERR_READ);
                });
            }
        }

        var zipReader = {
            getEntries: function(callback) {
                var worker = this._worker;
                // look for End of central directory record
                seekEOCDR(function(dataView) {
                    var datalength, fileslength;
                    datalength = dataView.getUint32(16, true);
                    fileslength = dataView.getUint16(8, true);
                    if (datalength < 0 || datalength >= reader.size) {
                        onerror(ERR_BAD_FORMAT);
                        return;
                    }
                    reader.readUint8Array(datalength, reader.size - datalength, function(bytes) {
                        var i, index = 0,
                            entries = [],
                            entry, filename, comment, data = getDataHelper(bytes.length, bytes);
                        for (i = 0; i < fileslength; i++) {
                            entry = new Entry();
                            entry._worker = worker;
                            if (data.view.getUint32(index) != 0x504b0102) {
                                onerror(ERR_BAD_FORMAT);
                                return;
                            }
                            readCommonHeader(entry, data, index + 6, true, onerror);
                            entry.commentLength = data.view.getUint16(index + 32, true);
                            entry.directory = ((data.view.getUint8(index + 38) & 0x10) == 0x10);
                            entry.offset = data.view.getUint32(index + 42, true);
                            filename = getString(data.array.subarray(index + 46, index + 46 + entry.filenameLength));
                            entry.filename = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(filename) : decodeASCII(filename);
                            if (!entry.directory && entry.filename.charAt(entry.filename.length - 1) == "/")
                                entry.directory = true;
                            comment = getString(data.array.subarray(index + 46 + entry.filenameLength + entry.extraFieldLength, index + 46 + entry.filenameLength + entry.extraFieldLength + entry.commentLength));
                            entry.comment = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(comment) : decodeASCII(comment);
                            entries.push(entry);
                            index += 46 + entry.filenameLength + entry.extraFieldLength + entry.commentLength;
                        }
                        callback(entries);
                    }, function() {
                        onerror(ERR_READ);
                    });
                });
            },
            close: function(callback) {
                if (this._worker) {
                    this._worker.terminate();
                    this._worker = null;
                }
                if (callback)
                    callback();
            },
            _worker: null
        };

        if (!obj.zip.useWebWorkers)
            callback(zipReader);
        else {
            createWorker('inflater',
                function(worker) {
                    zipReader._worker = worker;
                    callback(zipReader);
                },
                function(err) {
                    onerror(err);
                }
            );
        }
    }

    // ZipWriter

    function encodeUTF8(string) {
        return unescape(encodeURIComponent(string));
    }

    function getBytes(str) {
        var i, array = [];
        for (i = 0; i < str.length; i++)
            array.push(str.charCodeAt(i));
        return array;
    }

    function createZipWriter(writer, callback, onerror, dontDeflate) {
        var files = {}, filenames = [],
            datalength = 0;
        var deflateSN = 0;

        function onwriteerror(err) {
            onerror(err || ERR_WRITE);
        }

        function onreaderror(err) {
            onerror(err || ERR_READ_DATA);
        }

        var zipWriter = {
            add: function(name, reader, onend, onprogress, options) {
                var header, filename, date;
                var worker = this._worker;

                function writeHeader(callback) {
                    var data;
                    date = options.lastModDate || new Date();
                    header = getDataHelper(26);
                    files[name] = {
                        headerArray: header.array,
                        directory: options.directory,
                        filename: filename,
                        offset: datalength,
                        comment: getBytes(encodeUTF8(options.comment || ""))
                    };
                    header.view.setUint32(0, 0x14000808);
                    if (options.version)
                        header.view.setUint8(0, options.version);
                    if (!dontDeflate && options.level !== 0 && !options.directory)
                        header.view.setUint16(4, 0x0800);
                    header.view.setUint16(6, (((date.getHours() << 6) | date.getMinutes()) << 5) | date.getSeconds() / 2, true);
                    header.view.setUint16(8, ((((date.getFullYear() - 1980) << 4) | (date.getMonth() + 1)) << 5) | date.getDate(), true);
                    header.view.setUint16(22, filename.length, true);
                    data = getDataHelper(30 + filename.length);
                    data.view.setUint32(0, 0x504b0304);
                    data.array.set(header.array, 4);
                    data.array.set(filename, 30);
                    datalength += data.array.length;
                    writer.writeUint8Array(data.array, callback, onwriteerror);
                }

                function writeFooter(compressedLength, crc32) {
                    var footer = getDataHelper(16);
                    datalength += compressedLength || 0;
                    footer.view.setUint32(0, 0x504b0708);
                    if (typeof crc32 != "undefined") {
                        header.view.setUint32(10, crc32, true);
                        footer.view.setUint32(4, crc32, true);
                    }
                    if (reader) {
                        footer.view.setUint32(8, compressedLength, true);
                        header.view.setUint32(14, compressedLength, true);
                        footer.view.setUint32(12, reader.size, true);
                        header.view.setUint32(18, reader.size, true);
                    }
                    writer.writeUint8Array(footer.array, function() {
                        datalength += 16;
                        onend();
                    }, onwriteerror);
                }

                function writeFile() {
                    options = options || {};
                    name = name.trim();
                    if (options.directory && name.charAt(name.length - 1) != "/")
                        name += "/";
                    if (files.hasOwnProperty(name)) {
                        onerror(ERR_DUPLICATED_NAME);
                        return;
                    }
                    filename = getBytes(encodeUTF8(name));
                    filenames.push(name);
                    writeHeader(function() {
                        if (reader)
                            if (dontDeflate || options.level === 0)
                                copy(worker, deflateSN++, reader, writer, 0, reader.size, true, writeFooter, onprogress, onreaderror, onwriteerror);
                            else
                                deflate(worker, deflateSN++, reader, writer, options.level, writeFooter, onprogress, onreaderror, onwriteerror);
                            else
                                writeFooter();
                    }, onwriteerror);
                }

                if (reader)
                    reader.init(writeFile, onreaderror);
                else
                    writeFile();
            },
            close: function(callback) {
                if (this._worker) {
                    this._worker.terminate();
                    this._worker = null;
                }

                var data, length = 0,
                    index = 0,
                    indexFilename, file;
                for (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {
                    file = files[filenames[indexFilename]];
                    length += 46 + file.filename.length + file.comment.length;
                }
                data = getDataHelper(length + 22);
                for (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {
                    file = files[filenames[indexFilename]];
                    data.view.setUint32(index, 0x504b0102);
                    data.view.setUint16(index + 4, 0x1400);
                    data.array.set(file.headerArray, index + 6);
                    data.view.setUint16(index + 32, file.comment.length, true);
                    if (file.directory)
                        data.view.setUint8(index + 38, 0x10);
                    data.view.setUint32(index + 42, file.offset, true);
                    data.array.set(file.filename, index + 46);
                    data.array.set(file.comment, index + 46 + file.filename.length);
                    index += 46 + file.filename.length + file.comment.length;
                }
                data.view.setUint32(index, 0x504b0506);
                data.view.setUint16(index + 8, filenames.length, true);
                data.view.setUint16(index + 10, filenames.length, true);
                data.view.setUint32(index + 12, length, true);
                data.view.setUint32(index + 16, datalength, true);
                writer.writeUint8Array(data.array, function() {
                    writer.getData(callback);
                }, onwriteerror);
            },
            _worker: null
        };

        if (!obj.zip.useWebWorkers)
            callback(zipWriter);
        else {
            createWorker('deflater',
                function(worker) {
                    zipWriter._worker = worker;
                    callback(zipWriter);
                },
                function(err) {
                    onerror(err);
                }
            );
        }
    }

    function resolveURLs(urls) {
        var a = document.createElement('a');
        return urls.map(function(url) {
            a.href = url;
            return a.href;
        });
    }

    var DEFAULT_WORKER_SCRIPTS = {
        deflater: ['z-worker.js', 'deflate.js'],
        inflater: ['z-worker.js', 'inflate.js']
    };

    function createWorker(type, callback, onerror) {
        if (obj.zip.workerScripts !== null && obj.zip.workerScriptsPath !== null) {
            onerror(new Error('Either zip.workerScripts or zip.workerScriptsPath may be set, not both.'));
            return;
        }
        var scripts;
        if (obj.zip.workerScripts) {
            scripts = obj.zip.workerScripts[type];
            if (!Array.isArray(scripts)) {
                onerror(new Error('zip.workerScripts.' + type + ' is not an array!'));
                return;
            }
            scripts = resolveURLs(scripts);
        } else {
            scripts = DEFAULT_WORKER_SCRIPTS[type].slice(0);
            scripts[0] = (obj.zip.workerScriptsPath || '') + scripts[0];
        }
        var worker = new Worker(scripts[0]);
        // record total consumed time by inflater/deflater/crc32 in this worker
        worker.codecTime = worker.crcTime = 0;
        worker.postMessage({
            type: 'importScripts',
            scripts: scripts.slice(1)
        });
        worker.addEventListener('message', onmessage);

        function onmessage(ev) {
            var msg = ev.data;
            if (msg.error) {
                worker.terminate(); // should before onerror(), because onerror() may throw.
                onerror(msg.error);
                return;
            }
            if (msg.type === 'importScripts') {
                worker.removeEventListener('message', onmessage);
                worker.removeEventListener('error', errorHandler);
                callback(worker);
            }
        }
        // catch entry script loading error and other unhandled errors
        worker.addEventListener('error', errorHandler);

        function errorHandler(err) {
            worker.terminate();
            onerror(err);
        }
    }

    function onerror_default(error) {
        console.error(error);
    }
    obj.zip = {
        Reader: Reader,
        Writer: Writer,
        BlobReader: BlobReader,
        Data64URIReader: Data64URIReader,
        TextReader: TextReader,
        BlobWriter: BlobWriter,
        Data64URIWriter: Data64URIWriter,
        TextWriter: TextWriter,
        createReader: function(reader, callback, onerror) {
            onerror = onerror || onerror_default;

            reader.init(function() {
                createZipReader(reader, callback, onerror);
            }, onerror);
        },
        createWriter: function(writer, callback, onerror, dontDeflate) {
            onerror = onerror || onerror_default;
            dontDeflate = !! dontDeflate;

            writer.init(function() {
                createZipWriter(writer, callback, onerror, dontDeflate);
            }, onerror);
        },
        useWebWorkers: true,
        /**
         * Directory containing the default worker scripts (z-worker.js, deflate.js, and inflate.js), relative to current base url.
         * E.g.: zip.workerScripts = './';
         */
        workerScriptsPath: null,
        /**
         * Advanced option to control which scripts are loaded in the Web worker. If this option is specified, then workerScriptsPath must not be set.
         * workerScripts.deflater/workerScripts.inflater should be arrays of urls to scripts for deflater/inflater, respectively.
         * Scripts in the array are executed in order, and the first one should be z-worker.js, which is used to start the worker.
         * All urls are relative to current base url.
         * E.g.:
         * zip.workerScripts = {
         *   deflater: ['z-worker.js', 'deflate.js'],
         *   inflater: ['z-worker.js', 'inflate.js']
         * };
         */
        workerScripts: null,
    };

})(this);
/*
    This app has been copied from https://github.com/wrackzone/project-kilo/tree/master/portfolio-timesheet-export and modified to fit TS Template.
*/

var app = null;

Ext.define('PTApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    stateful: true,
    id: 'app',
    cache: [],
    config: {
        defaultSettings: {
            extApplicationValue:'RALLY',
            extApplication:true
        }
    },
    getSettingsFields: function() {
        var me = this;

        return  [
            {
                name: 'extApplication',
                xtype: 'rallycheckboxfield',
                boxLabelAlign: 'after',
                fieldLabel: '',
                margin: 25,
                boxLabel: 'Include &lt;EXTAPPLICATION&gt;RALLY&lt;/EXTAPPLICATION&gt; to all records in the E1BPCATS1.xml file.'
            },
            {
                name: 'extApplicationValue',
                xtype: 'textfield',
                fieldLabel: '&lt;EXTAPPLICATION/&gt; tag Value',
                labelWidth: 125,
                labelAlign: 'left',
                minWidth: 200,
                margin: 25
            }];
    },
    items: [{
        id: 'panel',
        xtype: 'panel',
        layout: 'column',
        items: [{
            name: 'intervalType',
            xtype: 'combo',
            store: Ext.create("Ext.data.ArrayStore", {
                fields: ['interval'],
                data: [
                    ['Today'],
                    ['This Week'],
                    ['Last Week'],
                    ['This Month'],
                    ['Last Month']
                ]
            }),
            valueField: 'interval',
            displayField: 'interval',
            queryMode: 'local',
            forceSelection: true,
            boxLabelAlign: 'after',
            fieldLabel: 'Interval',
            margin: '5 5 5 5',
            listeners: {
                scope: this,
                select: function(list, item) {
                    var startDateCmp = Ext.getCmp('startDate');
                    var endDateCmp = Ext.getCmp('endDate');
                    var start, end;

                    var dt = new Date();

                    switch (_.first(item).get('interval')) {
                        case 'Today':
                            start = Ext.Date.clearTime(dt);
                            end = Ext.Date.clearTime(Ext.Date.add(start, Ext.Date.MILLI, ((24 * 60 * 60 * 1000) - 1)));
                            break;
                        case 'This Week':
                            start = Ext.Date.clearTime(Ext.Date.subtract(dt, Ext.Date.DAY, dt.getDay())); //Sunday AM
                            end = Ext.Date.clearTime(Ext.Date.add(start, Ext.Date.MILLI, ((7 * 24 * 60 * 60 * 1000) - 1))); //Saturday PM
                            break;
                        case 'Last Week':
                            start = Ext.Date.clearTime(Ext.Date.subtract(dt, Ext.Date.DAY, 7 + dt.getDay())); //Sunday AM
                            end = Ext.Date.clearTime(Ext.Date.add(start, Ext.Date.MILLI, ((7 * 24 * 60 * 60 * 1000) - 1))); //Saturday PM
                            break;
                        case 'This Month':
                            start = new Date("1/" + dt.getMonth() + 1 + "/" + dt.getFullYear());
                            end = Ext.Date.subtract(Ext.Date.add(start, Ext.Date.MONTH, 1), Ext.Date.MILLI, 1);
                            break;
                        case 'Last Month':
                            start = new Date("1/" + dt.getMonth() + 1 + "/" + dt.getFullYear());
                            start = Ext.Date.subtract(start, Ext.Date.MONTH, 1);
                            end = Ext.Date.subtract(Ext.Date.add(start, Ext.Date.MONTH, 1), Ext.Date.MILLI, 1);
                            break;
                    }

                    startDateCmp.setValue(start);
                    startDateCmp.getValue();
                    endDateCmp.setValue(end);
                    endDateCmp.getValue();
                    app.createTimeValueStore();
                }
            }
        }, {
            id: 'startDate',
            margin: '5 5 5 5',
            xtype: 'datefield',
            format: 'd M Y',
            stateful: true,
            stateId: 'tsDate1',
            fieldLabel: 'Start Date',
            value: new Date(),
            listeners: {
                select: function(field, value) {
                    var endDateCmp = Ext.getCmp('endDate');
                    if (endDateCmp.getValue() < value) {
                        endDateCmp.setValue(value);
                    }
                    app.createTimeValueStore();
                }
            }
        }, {
            id: 'endDate',
            margin: '5 5 5 5',
            xtype: 'datefield',
            stateful: true,
            stateId: 'tsDate2',
            format: 'd M Y',
            fieldLabel: 'End Date',
            value: new Date(),
            listeners: {
                select: function(field, value) {
                    var startDateCmp = Ext.getCmp('startDate');
                    if (startDateCmp.getValue() > value) {
                        startDateCmp.setValue(value);
                    }
                    app.createTimeValueStore();
                }
            }
        }, {
            id: 'exportButton',
            margin: '5 5 5 5',
            xtype: 'rallybutton',
            text: 'Export',
            handler: function() {
                var saveDialog = Ext.create('Rally.ui.dialog.Dialog', {
                    autoShow: true,
                    draggable: true,
                    width: 300,
                    title: 'Export all records',
                    items: [{
                            xtype: 'rallybutton',
                            text: 'CSV',
                            handler: function() {
                                app.exporter.exportCSV(app.grid);
                                saveDialog.destroy();
                            }
                        }, {
                            xtype: 'rallybutton',
                            text: 'SAP XML',
                            handler: function() {
                                app.exporter.exportSAPXML(app.grid,{'extApplication':app.getSetting('extApplication'),'extApplicationValue':app.getSetting('extApplicationValue')});
                                saveDialog.destroy();
                            }
                        },

                        {
                            xtype: 'rallybutton',
                            text: 'Cancel',
                            handler: function() {
                                Ext.destroy(saveDialog);
                            },
                            flex: 1
                        }
                    ]

                });
            }
        }]
    }],

    launch: function() {

        app = this;

        this._onLoad();
    },

    _onLoad: function() {

        app._loadAStoreWithAPromise(
                'TypeDefinition',
                true, [{
                    property: "Ordinal",
                    operator: "!=",
                    value: -1
                }])
            .then({
                success: function(records) {
                    app.piTypes = records;
                    console.log("pitypes:", records);
                    app.exporter = Ext.create("GridExporter");
                    app.createTimeValueStore();
                }
            });
    },

    createTimeValueStore: function() {

        app.showMask("Loading Time Sheet Values");

        // clear the grid
        if (!_.isNull(app.grid)) {
            app.remove(app.grid);
        }

        var nr = null;
        if ((nr = Ext.getCmp('noRecords'))) {
            nr.destroy();
        }

        var filter = app._getDateFilter();

        // exclude zero value items
        filter.push({
            property: 'Hours',
            operator: '>',
            value: 0
        });

        //console.log(filter);

        Ext.create('Rally.data.wsapi.Store', {
            model: "TimeEntryValue",
            fetch: true,
            filters: filter,
            limit: 'Infinity'
        }).load({
            callback: function(records, operation, successful) {
                if (records.length === 0) {
                    app.hideMask();
                    app.add({
                        html: "No records for this date range",
                        itemId: "norecords",
                        id: "noRecords"
                    });
                }
                app.readRelatedValues(records,
                    function() {
                        app.hideMask();
                        var message = app.down("#norecords");
                        if (!_.isUndefined(message)) {
                            app.remove(message);
                        }
                        console.log('records', records);
                        app.createArrayStoreFromRecords(records);
                    }
                );
            }
        });
    },

    getFieldValue: function(record, field) {
        // returns the most specific value for a field
        // ie. Task -> Story -> Feature -> Epic
        var hasValue = function(value) {
            return !_.isUndefined(value) && !_.isNull(value) && value !== "";
        };
        var object = _.find(record.get("Hierarchy"), function(h) {
            return hasValue(h.get(field));
        });

        return (!_.isUndefined(object) && !_.isNull(object) ? object.get(field) : null);
    },

    getTypeFieldValue: function(record, type, field) {

        var object = _.find(record.get("Hierarchy"), function(h) {
            return h.get("_type") === type.get("TypePath").toLowerCase();
        });

        return (!_.isUndefined(object) && !_.isNull(object) ? object.get(field) : "");
    },

    createArrayStoreFromRecords: function(records) {

        var fields = [{
            displayName: 'User',
            name: 'UserName'
        }, {
            displayName: 'Task',
            name: 'TaskDisplayString'
        }, {
            displayName: 'Project',
            name: 'ProjectDisplayString'
        }, {
            displayName: 'Work Product',
            name: 'WorkProductDisplayString'
        }, {
            displayName: 'Feature ID',
            name: 'FeatureID'
        }, {
            displayName: 'Feature Title',
            name: 'FeatureName'
        }, {
            displayName: 'SAP Project',
            name: 'c_SAPProject'
        },{
            displayName: 'SAP Network',
            name: 'c_SAPNetwork'
        }, {
            displayName: 'SAP Operation',
            name: 'c_SAPOperation'
        }, {
            displayName: 'SAP Sub Operation',
            name: 'c_SAPSubOperation'
        }, {
            displayName: 'Epic ID',
            name: 'EpicID'
        }, {
            displayName: 'Epic Title',
            name: 'EpicName'
        }, {
            displayName: 'Hours Entered',
            name: 'Hours'
        }, {
            displayName: 'Unique ID',
            name: 'ObjectID'
        }, {
            displayName: 'Date',
            name: 'Date'
        }, {
            displayName: 'Employee ID',
            name: 'c_KMDEmployeeID'
        }, {
            displayName: 'Hierarchy',
            name: 'Hierarchy'
        }];

        // convert records into a json data structure
        var data = _.map(records, function(r) {
            
            return {
                "UserName": r.get("UserObject").get("UserName"),
                "TaskDisplayString": r.get("TimeEntryItemObject").get("TaskDisplayString"),
                "ProjectDisplayString": r.get("TimeEntryItemObject").get("ProjectDisplayString"),
                "WorkProductDisplayString": r.get("TimeEntryItemObject").get("WorkProductDisplayString"),
                "FeatureID": app.getTypeFieldValue(r, app.piTypes[0], "FormattedID"),
                "FeatureName": app.getTypeFieldValue(r, app.piTypes[0], "Name"),
                'c_SAPProject': app.getFieldValue(r, 'c_SAPProject'),
                'c_SAPNetwork': app.getFieldValue(r, 'c_SAPNetwork'),
                'c_SAPOperation': app.getFieldValue(r, 'c_SAPOperation'),
                'c_SAPSubOperation': app.getFieldValue(r, 'c_SAPSubOperation'),
                'EpicID': app.getTypeFieldValue(r, app.piTypes[1], "FormattedID"),
                'EpicName': app.getTypeFieldValue(r, app.piTypes[1], "Name"),
                'Hours': r.get('Hours'),
                'ObjectID': r.get("ObjectID"),
                'Date': Ext.Date.format(r.get("DateVal"), "Ymd"),
                'c_KMDEmployeeID': r.get("UserObject").get("c_KMDEmployeeID"),
                'Hierarchy': r.get("Hierarchy")
            };
        });

        var store = Ext.create('Ext.data.JsonStore', {
            fields: fields,
            data: data
        });

        app.grid = new Ext.grid.GridPanel({
            header: false,
            id: 'tsGrid',
            title: 'TimeSheetData',
            features: [{
                ftype: 'grouping',
                showSummaryRow: true,
                groupHeaderTpl: ' {name}'
            }, {
                ftype: 'summary'
            }],
            store: store,
            columns: _.map(fields, function(f) {
                if (f.name === 'Hours') {
                    return {
                        text: f.displayName,
                        dataIndex: f.name,
                        summaryType: 'sum',
                        summaryRenderer: function(value, summaryData, dataIndex) {
                            return Ext.String.format('<div style="background-color:#E4EECF">Total: {0}</div>', value);
                        }
                    };
                } else if (f.name === 'UserName') {
                    return {
                        text: f.displayName,
                        dataIndex: f.name,
                        flex: 1,
                        summaryType: 'count',
                        summaryRenderer: function(value, summaryData, dataIndex) {
                            return Ext.String.format('<div style="background-color:#E4EECF"> {0} item{1}</div>', value, value > 1 ? 's' : '');
                        }
                    };
                } else if (f.name === 'TaskDisplayString' ||
                    f.name === 'WorkProductDisplayString' ||
                    f.name === "FeatureID" ||
                    f.name === "EpicID") {
                    return {
                        text: f.displayName,
                        dataIndex: f.name,
                        renderer: function(value, metaData, record, rowIdx, colIdx, store, view) {

                            return app.renderLink(value, record);
                        }
                    };
                } else if (f.name === 'Hierarchy') {
                    return {
                        text: f.displayName,
                        dataIndex: f.name,
                        visible: false,
                        hidden: true
                    };
                } else
                    return {
                        text: f.displayName,
                        dataIndex: f.name
                    };
            })
        });

        this.add(app.grid);


    },

    // creates a url link for the column based on the formatted id in the column
    renderLink: function(textValue, record) {
        
        var fid = _.first(textValue.split(":"));
        
        var obj = _.find(record.get("Hierarchy"), function(hObj) {
            return fid === hObj.get("FormattedID");
        });
        if (!_.isUndefined(obj) && !_.isNull(obj)) {
            return '<a href=' + Rally.nav.Manager.getDetailUrl(obj) + '>' + textValue + '</a>';
        }
        return textValue;
    },

    readRelatedValues: function(values, callback) {
        // time entry items
        app.readTimeEntryItems(values).then({

            success: function(items) {
                app.setValues(values, items, "TimeEntryItemObject");
                // users
                app.readUsers(items).then({
                    success: function(users) {
                        app.setValues(values, users, "UserObject");
                        // read work item hierarchies
                        app.readHierarchies(items).then({
                            success: function(hierarchies) {

                                app.setValues(values, hierarchies, "Hierarchy");
                                callback();
                            }
                        });
                    }
                });
            }
        });
    },

    readHierarchies: function(items) {

        var deferred = Ext.create('Deft.Deferred');
        // read task or workproduct, depending on timeentryitem type
        var p = _.map(items, function(item) {
            var obj = (!_.isUndefined(item.get("Task")) &&
                    !_.isNull(item.get("Task"))) ?
                item.get("Task") : item.get("WorkProduct");
            // return app.readObject(obj._type,obj);
            return app.readObject(obj);
        });

        Deft.Promise.all(p).then({
            success: function(values) {
                // get parent hierarchy
                var p2 = _.map(values, function(value) {
                    return app.recurseUpObject(value);
                });
                Deft.Promise.all(p2).then({
                    success: function(hierarchies) {
                        deferred.resolve(hierarchies);
                    }
                });
            }
        });
        return deferred.promise;
    },

    setValues: function(items, values, attrName) {
        _.each(items, function(item, x) {
            item.set(attrName, values[x]);
        });
    },

    // TimesheetEntryItems -> Stories -> Features -> Epics

    // readObject : function(model,ref) {
    readObject: function(object) {

        var deferred = Ext.create('Deft.Deferred');

        if (_.isNull(object)) {
            deferred.resolve(null);
        } else {
            var obj = _.find(app.cache, function(cacheObj) {
                if (cacheObj.object._ref === object._ref) {
                    return cacheObj.promise.promise;
                }
            });

            if (!_.isUndefined(obj) && !_.isNull(obj)) {
                return obj.promise.promise;
            } else {
                Rally.data.ModelFactory.getModel({
                    type: object._type,
                    success: function(model) {
                        model.load(object, {
                            fetch: true,
                            callback: function(result, operation) {
                                
                                deferred.resolve(result);
                            }
                        });
                    }
                });
                app.cache.push({
                    object: object,
                    promise: deferred
                });
                return deferred.promise;
            }
        }
    },

    // given an object, it will read all parent items based on type and return in a list
    recurseUpObject: function(obj) {

        var deferred = Ext.create('Deft.Deferred');
        var list = []; //var stack = 1;

        var parentItem = function(obj, callback) {
            var type = _.first(obj.get("_type").split("/")).toLowerCase();

            switch (type) {
                case 'task':
                    parentAttr = 'WorkProduct';
                    break;
                case 'defect':
                    parentAttr = 'Requirement';
                    break;
                case 'hierarchicalrequirement':
                    parentAttr = (!_.isNull(obj.get("Parent")) ? "Parent" : "PortfolioItem");
                    break;
                case 'portfolioitem':
                    parentAttr = 'Parent';
                    break;
            }
            
            var parentRef = obj.get(parentAttr);
            if (!_.isUndefined(parentRef) && !_.isNull(parentRef)) {
                // app.readObject(parentRef._type,parentRef).then({
                app.readObject(parentRef).then({
                    success: function(r) {
                        callback(r);
                    }
                });
            } else {
                callback(null);
            }
        };

        var walk = function(root) {
            list.push(root);
            parentItem(root, function(result) {
                if (result !== null) {
                    walk(result);
                } else {
                    deferred.resolve(list);
                }
            });
        };

        if (_.isUndefined(obj) || _.isNull(obj)) {
            deferred.resolve(null);
        } else {
            walk(obj);
            return deferred.promise;
        }
    },

    readUsers: function(items) {
        var promises = _.map(items, function(item) {
            var deferred = Ext.create('Deft.Deferred');
            var userRef = item.get("User");
            if (_.isUndefined(userRef) || _.isNull(userRef)) {
                deferred.resolve(null);
            } else {
                // app.readObject('User',userRef).then({
                app.readObject(userRef).then({
                    success: function(obj) {
                        deferred.resolve(obj);
                    }
                });
            }
            return deferred.promise;
        });
        return Deft.Promise.all(promises);
    },

    readTimeEntryItems: function(values) {
        var promises = _.map(values, function(v) {
            var deferred = Ext.create('Deft.Deferred');
            var ref = v.get("TimeEntryItem");

            //app.readObject('TimeEntryItem',ref).then({
            app.readObject(ref).then({
                success: function(obj) {
                    deferred.resolve(obj);
                }
            });
            return deferred.promise;
        });
        return Deft.Promise.all(promises);
    },

    _getDateFilter: function() {
        var startDateCmp = Ext.getCmp('startDate').getValue();
        var endDateCmp = Ext.getCmp('endDate').getValue();
        var start = Rally.util.DateTime.toIsoString(startDateCmp, false);
        var end = Rally.util.DateTime.toIsoString(endDateCmp, false);

        return [{
            property: 'DateVal',
            operator: '>=',
            value: start
        }, {
            property: 'DateVal',
            operator: '<=',
            value: end
        }];
    },

    _onSelect: function() {
        var grid = Ext.getCmp('tsGrid'),
            store = grid.getStore();

        store.clearFilter(true);
        store.filter(app._getDateFilter());
    },

    _onSelectDate: function(a, b, c) {
        console.log(a, b, c);
    },

    showMask: function(msg) {
        if (this.getEl()) {
            this.getEl().unmask();
            this.getEl().mask(msg);
        }
    },
    hideMask: function() {
        this.getEl().unmask();
    },
    _loadAStoreWithAPromise: function(model_name, model_fields, filters, ctx, order) {

        var deferred = Ext.create('Deft.Deferred');
        var me = this;

        var config = {
            model: model_name,
            fetch: model_fields,
            filters: filters,
            limit: 'Infinity'
        };
        if (!_.isUndefined(ctx) && !_.isNull(ctx)) {
            config.context = ctx;
        }
        if (!_.isUndefined(order) && !_.isNull(order)) {
            config.order = order;
        }

        Ext.create('Rally.data.wsapi.Store', config).load({
            callback: function(records, operation, successful) {
                if (successful) {
                    deferred.resolve(records);
                } else {
                    deferred.reject('Problem loading: ' + operation.error.errors.join('. '));
                }
            }
        });
        return deferred.promise;
    },
    getOptions: function() {
        return [
            {
                text: 'About...',
                handler: this._launchInfo,
                scope: this
            }
        ];
    },
    
    _launchInfo: function() {
        if ( this.about_dialog ) { this.about_dialog.destroy(); }
        this.about_dialog = Ext.create('Rally.technicalservices.InfoLink',{});
    },
    
    isExternal: function(){
        return typeof(this.getAppId()) == 'undefined';
    }

});
            
               Rally.launchApp('PTApp', {
                   name: 'Portfolio Timesheet App'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}
    </style>

</head>
<body></body>
</html>